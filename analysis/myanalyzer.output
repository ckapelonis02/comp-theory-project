Nonterminals useless in grammar

    comp_operand


Terminals unused in grammar

    PERIOD


Rules useless in grammar

  168 comp_operand: comp_var_name
  169             | comp_func_call
  170             | INTEGER
  171             | FLOAT
  172             | bool_dt
  173             | CONST_STRING


State 336 conflicts: 16 reduce/reduce


Grammar

    0 $accept: input $end

    1 input: comp_decl_rec const_decl_rec var_decl_rec func_decl_rec main_func

    2 func_decl_rec: ε
    3              | func_decl_rec func_decl

    4 var_decl_rec: ε
    5             | var_decl_rec var_decl

    6 const_decl_rec: ε
    7               | const_decl_rec const_decl

    8 comp_decl_rec: ε
    9              | comp_decl_rec comp_decl

   10 main_func: main_header func_body func_end

   11 main_header: KEYWORD_DEF KEYWORD_MAIN LPAREN RPAREN COLON

   12 func_decl: func_header func_body func_end

   13 func_header: KEYWORD_DEF IDENTIFIER LPAREN func_param_list RPAREN COLON
   14            | KEYWORD_DEF IDENTIFIER LPAREN func_param_list RPAREN MINUS GT var_type COLON

   15 func_param_list: ε
   16                | func_arg
   17                | func_param_list COMMA func_arg

   18 func_arg: func_arg_name COLON var_type

   19 func_arg_name: IDENTIFIER
   20              | IDENTIFIER LBRACKET RBRACKET

   21 func_body: const_decl_rec var_decl_rec stmts

   22 func_end: KEYWORD_ENDDEF SEMICOLON

   23 var_decl: var_decl_list COLON var_type SEMICOLON

   24 var_decl_list: var_name
   25              | var_decl_list COMMA var_name

   26 var_name: IDENTIFIER
   27         | IDENTIFIER LBRACKET expr RBRACKET

   28 var_type: primitive_dt
   29         | IDENTIFIER

   30 primitive_dt: KEYWORD_SCALAR
   31             | KEYWORD_INTEGER
   32             | KEYWORD_STR
   33             | KEYWORD_BOOL

   34 bool_dt: KEYWORD_TRUE
   35        | KEYWORD_FALSE

   36 comp_decl: KEYWORD_COMP IDENTIFIER COLON comp_var_decl_rec comp_func_decl_rec KEYWORD_ENDCOMP SEMICOLON

   37 comp_func_decl_rec: ε
   38                   | comp_func_decl_rec comp_func_decl

   39 comp_func_decl: comp_func_header comp_func_body func_end

   40 comp_func_body: const_decl_rec var_decl_rec comp_stmts

   41 comp_func_header: KEYWORD_DEF IDENTIFIER LPAREN comp_func_param_list RPAREN COLON
   42                 | KEYWORD_DEF IDENTIFIER LPAREN comp_func_param_list RPAREN MINUS GT var_type COLON

   43 comp_func_param_list: ε
   44                     | func_arg
   45                     | comp_func_param_list COMMA func_arg

   46 comp_var_decl_rec: comp_var_decl
   47                  | comp_var_decl_rec comp_var_decl

   48 comp_var_decl: comp_var_decl_list COLON var_type SEMICOLON

   49 comp_var_decl_list: comp_var_name_
   50                   | comp_var_decl_list COMMA comp_var_name_

   51 comp_var_name_: HASHTAG var_name

   52 comp_var_name: HASHTAG var_name
   53              | var_name

   54 comp_stmts: comp_stmt
   55           | comp_stmts comp_stmt

   56 comp_stmt: empty_stmt
   57          | comp_if_stmt
   58          | comp_func_call SEMICOLON
   59          | comp_return_stmt
   60          | break_stmt
   61          | continue_stmt
   62          | comp_while_stmt
   63          | comp_for_stmt
   64          | comp_assign_stmt
   65          | comp_range_comprehension
   66          | comp_arr_comprehension

   67 comp_range_comprehension: comp_var_name COLON_ASSIGN LBRACKET comp_expr KEYWORD_FOR comp_var_name COLON INTEGER RBRACKET COLON var_type SEMICOLON

   68 comp_arr_comprehension: comp_var_name COLON_ASSIGN LBRACKET comp_expr KEYWORD_FOR comp_var_name COLON var_type KEYWORD_IN comp_var_name KEYWORD_OF INTEGER RBRACKET COLON var_type SEMICOLON

   69 comp_for_stmt: KEYWORD_FOR comp_var_name KEYWORD_IN LBRACKET comp_expr COLON comp_expr COLON comp_expr RBRACKET COLON comp_stmts KEYWORD_ENDFOR SEMICOLON
   70              | KEYWORD_FOR comp_var_name KEYWORD_IN LBRACKET expr COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON

   71 comp_while_stmt: KEYWORD_WHILE LPAREN comp_expr RPAREN COLON comp_stmts KEYWORD_ENDWHILE SEMICOLON

   72 comp_assign_stmt: comp_var_name ASSIGN comp_expr SEMICOLON
   73                 | comp_var_name PLUS_ASSIGN comp_expr SEMICOLON
   74                 | comp_var_name MINUS_ASSIGN comp_expr SEMICOLON
   75                 | comp_var_name MULT_ASSIGN comp_expr SEMICOLON
   76                 | comp_var_name DIV_ASSIGN comp_expr SEMICOLON
   77                 | comp_var_name MOD_ASSIGN comp_expr SEMICOLON
   78                 | comp_var_name COLON_ASSIGN comp_expr SEMICOLON

   79 comp_return_stmt: KEYWORD_RETURN SEMICOLON
   80                 | KEYWORD_RETURN comp_expr SEMICOLON

   81 comp_if_stmt: KEYWORD_IF LPAREN comp_expr RPAREN COLON comp_stmts KEYWORD_ENDIF SEMICOLON
   82             | KEYWORD_IF LPAREN comp_expr RPAREN COLON comp_stmts KEYWORD_ELSE COLON comp_stmts KEYWORD_ENDIF SEMICOLON

   83 comp_func_call: comp_var_name LPAREN comp_expr_list RPAREN

   84 comp_expr_list: ε
   85               | comp_expr
   86               | comp_expr_list COMMA comp_expr

   87 comp_expr: operand
   88          | comp_expr PLUS comp_expr
   89          | comp_expr MINUS comp_expr
   90          | comp_expr MULT comp_expr
   91          | comp_expr DIV comp_expr
   92          | comp_expr MOD comp_expr
   93          | comp_expr GT comp_expr
   94          | comp_expr LT comp_expr
   95          | comp_expr GEQ comp_expr
   96          | comp_expr LEQ comp_expr
   97          | comp_expr EQ comp_expr
   98          | comp_expr NEQ comp_expr
   99          | comp_expr KEYWORD_AND comp_expr
  100          | comp_expr KEYWORD_OR comp_expr
  101          | KEYWORD_NOT comp_expr
  102          | PLUS comp_expr
  103          | MINUS comp_expr
  104          | comp_expr POW comp_expr
  105          | LPAREN comp_expr RPAREN

  106 const_decl: KEYWORD_CONST IDENTIFIER ASSIGN expr COLON primitive_dt SEMICOLON

  107 expr: operand
  108     | expr PLUS expr
  109     | expr MINUS expr
  110     | expr MULT expr
  111     | expr DIV expr
  112     | expr MOD expr
  113     | expr GT expr
  114     | expr LT expr
  115     | expr GEQ expr
  116     | expr LEQ expr
  117     | expr EQ expr
  118     | expr NEQ expr
  119     | expr KEYWORD_AND expr
  120     | expr KEYWORD_OR expr
  121     | KEYWORD_NOT expr
  122     | PLUS expr
  123     | MINUS expr
  124     | expr POW expr
  125     | LPAREN expr RPAREN

  126 operand: var_name
  127        | func_call
  128        | INTEGER
  129        | FLOAT
  130        | bool_dt
  131        | CONST_STRING

  132 expr_list: ε
  133          | expr
  134          | expr_list COMMA expr

  135 stmts: stmt
  136      | stmts stmt

  137 stmt: empty_stmt
  138     | if_stmt
  139     | func_call SEMICOLON
  140     | return_stmt
  141     | break_stmt
  142     | continue_stmt
  143     | while_stmt
  144     | for_stmt
  145     | assign_stmt
  146     | range_comprehension
  147     | arr_comprehension

  148 range_comprehension: var_name COLON_ASSIGN LBRACKET expr KEYWORD_FOR var_name COLON INTEGER RBRACKET COLON var_type SEMICOLON

  149 arr_comprehension: var_name COLON_ASSIGN LBRACKET expr KEYWORD_FOR var_name COLON var_type KEYWORD_IN var_name KEYWORD_OF INTEGER RBRACKET COLON var_type SEMICOLON

  150 for_stmt: KEYWORD_FOR var_name KEYWORD_IN LBRACKET expr COLON expr COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON
  151         | KEYWORD_FOR var_name KEYWORD_IN LBRACKET expr COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON

  152 while_stmt: KEYWORD_WHILE LPAREN expr RPAREN COLON stmts KEYWORD_ENDWHILE SEMICOLON

  153 assign_stmt: var_name ASSIGN expr SEMICOLON
  154            | var_name PLUS_ASSIGN expr SEMICOLON
  155            | var_name MINUS_ASSIGN expr SEMICOLON
  156            | var_name MULT_ASSIGN expr SEMICOLON
  157            | var_name DIV_ASSIGN expr SEMICOLON
  158            | var_name MOD_ASSIGN expr SEMICOLON
  159            | var_name COLON_ASSIGN expr SEMICOLON

  160 return_stmt: KEYWORD_RETURN SEMICOLON
  161            | KEYWORD_RETURN expr SEMICOLON

  162 break_stmt: KEYWORD_BREAK SEMICOLON

  163 continue_stmt: KEYWORD_CONTINUE SEMICOLON

  164 empty_stmt: SEMICOLON

  165 if_stmt: KEYWORD_IF LPAREN expr RPAREN COLON stmts KEYWORD_ENDIF SEMICOLON
  166        | KEYWORD_IF LPAREN expr RPAREN COLON stmts KEYWORD_ELSE COLON stmts KEYWORD_ENDIF SEMICOLON

  167 func_call: IDENTIFIER LPAREN expr_list RPAREN


Terminals, with rules where they appear

    $end (0) 0
    error (256)
    KEYWORD_SCALAR (258) 30
    KEYWORD_STR (259) 32
    KEYWORD_BOOL (260) 33
    KEYWORD_TRUE (261) 34
    KEYWORD_FALSE (262) 35
    KEYWORD_CONST (263) 106
    KEYWORD_IF (264) 81 82 165 166
    KEYWORD_ELSE (265) 82 166
    KEYWORD_ENDIF (266) 81 82 165 166
    KEYWORD_FOR (267) 67 68 69 70 148 149 150 151
    KEYWORD_IN (268) 68 69 70 149 150 151
    KEYWORD_ENDFOR (269) 69 70 150 151
    KEYWORD_WHILE (270) 71 152
    KEYWORD_ENDWHILE (271) 71 152
    KEYWORD_BREAK (272) 162
    KEYWORD_CONTINUE (273) 163
    KEYWORD_NOT (274) 101 121
    KEYWORD_AND (275) 99 119
    KEYWORD_OR (276) 100 120
    KEYWORD_DEF (277) 11 13 14 41 42
    KEYWORD_ENDDEF (278) 22
    KEYWORD_MAIN (279) 11
    KEYWORD_RETURN (280) 79 80 160 161
    KEYWORD_COMP (281) 36
    KEYWORD_ENDCOMP (282) 36
    KEYWORD_OF (283) 68 149
    KEYWORD_INTEGER (284) 31
    LPAREN (285) 11 13 14 41 42 71 81 82 83 105 125 152 165 166 167
    RPAREN (286) 11 13 14 41 42 71 81 82 83 105 125 152 165 166 167
    COMMA (287) 17 25 45 50 86 134
    LBRACKET (288) 20 27 67 68 69 70 148 149 150 151
    RBRACKET (289) 20 27 67 68 69 70 148 149 150 151
    COLON (290) 11 13 14 18 23 36 41 42 48 67 68 69 70 71 81 82 106 148 149 150 151 152 165 166
    PERIOD (291)
    SEMICOLON (292) 22 23 36 48 58 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 106 139 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166
    PLUS (293) 88 102 108 122
    MINUS (294) 14 42 89 103 109 123
    MULT (295) 90 110
    DIV (296) 91 111
    MOD (297) 92 112
    POW (298) 104 124
    EQ (299) 97 117
    NEQ (300) 98 118
    LT (301) 94 114
    LEQ (302) 96 116
    GT (303) 14 42 93 113
    GEQ (304) 95 115
    ASSIGN (305) 72 106 153
    PLUS_ASSIGN (306) 73 154
    MINUS_ASSIGN (307) 74 155
    MULT_ASSIGN (308) 75 156
    DIV_ASSIGN (309) 76 157
    MOD_ASSIGN (310) 77 158
    COLON_ASSIGN (311) 67 68 78 148 149 159
    IDENTIFIER <str> (312) 13 14 19 20 26 27 29 36 41 42 106 167
    INTEGER <str> (313) 67 68 128 148 149
    FLOAT <str> (314) 129
    CONST_STRING <str> (315) 131
    HASHTAG (316) 51 52


Nonterminals, with rules where they appear

    $accept (62)
        on left: 0
    input (63)
        on left: 1
        on right: 0
    func_decl_rec <str> (64)
        on left: 2 3
        on right: 1 3
    var_decl_rec <str> (65)
        on left: 4 5
        on right: 1 5 21 40
    const_decl_rec <str> (66)
        on left: 6 7
        on right: 1 7 21 40
    comp_decl_rec <str> (67)
        on left: 8 9
        on right: 1 9
    main_func <str> (68)
        on left: 10
        on right: 1
    main_header <str> (69)
        on left: 11
        on right: 10
    func_decl <str> (70)
        on left: 12
        on right: 3
    func_header <str> (71)
        on left: 13 14
        on right: 12
    func_param_list <str> (72)
        on left: 15 16 17
        on right: 13 14 17
    func_arg <str> (73)
        on left: 18
        on right: 16 17 44 45
    func_arg_name <str> (74)
        on left: 19 20
        on right: 18
    func_body <str> (75)
        on left: 21
        on right: 10 12
    func_end <str> (76)
        on left: 22
        on right: 10 12 39
    var_decl <str> (77)
        on left: 23
        on right: 5
    var_decl_list <str> (78)
        on left: 24 25
        on right: 23 25
    var_name <str> (79)
        on left: 26 27
        on right: 24 25 51 52 53 126 148 149 150 151 153 154 155 156 157 158 159
    var_type <str> (80)
        on left: 28 29
        on right: 14 18 23 42 48 67 68 148 149
    primitive_dt <str> (81)
        on left: 30 31 32 33
        on right: 28 106
    bool_dt <str> (82)
        on left: 34 35
        on right: 130
    comp_decl <str> (83)
        on left: 36
        on right: 9
    comp_func_decl_rec <str> (84)
        on left: 37 38
        on right: 36 38
    comp_func_decl <str> (85)
        on left: 39
        on right: 38
    comp_func_body <str> (86)
        on left: 40
        on right: 39
    comp_func_header <str> (87)
        on left: 41 42
        on right: 39
    comp_func_param_list <str> (88)
        on left: 43 44 45
        on right: 41 42 45
    comp_var_decl_rec <str> (89)
        on left: 46 47
        on right: 36 47
    comp_var_decl <str> (90)
        on left: 48
        on right: 46 47
    comp_var_decl_list <str> (91)
        on left: 49 50
        on right: 48 50
    comp_var_name_ <str> (92)
        on left: 51
        on right: 49 50
    comp_var_name <str> (93)
        on left: 52 53
        on right: 67 68 69 70 72 73 74 75 76 77 78 83
    comp_stmts <str> (94)
        on left: 54 55
        on right: 40 55 69 71 81 82
    comp_stmt <str> (95)
        on left: 56 57 58 59 60 61 62 63 64 65 66
        on right: 54 55
    comp_range_comprehension <str> (96)
        on left: 67
        on right: 65
    comp_arr_comprehension <str> (97)
        on left: 68
        on right: 66
    comp_for_stmt <str> (98)
        on left: 69 70
        on right: 63
    comp_while_stmt <str> (99)
        on left: 71
        on right: 62
    comp_assign_stmt <str> (100)
        on left: 72 73 74 75 76 77 78
        on right: 64
    comp_return_stmt <str> (101)
        on left: 79 80
        on right: 59
    comp_if_stmt <str> (102)
        on left: 81 82
        on right: 57
    comp_func_call <str> (103)
        on left: 83
        on right: 58
    comp_expr_list <str> (104)
        on left: 84 85 86
        on right: 83 86
    comp_expr <str> (105)
        on left: 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105
        on right: 67 68 69 71 72 73 74 75 76 77 78 80 81 82 85 86 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105
    const_decl <str> (106)
        on left: 106
        on right: 7
    expr <str> (107)
        on left: 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125
        on right: 27 70 106 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 133 134 148 149 150 151 152 153 154 155 156 157 158 159 161 165 166
    operand <str> (108)
        on left: 126 127 128 129 130 131
        on right: 87 107
    expr_list <str> (109)
        on left: 132 133 134
        on right: 134 167
    stmts <str> (110)
        on left: 135 136
        on right: 21 70 136 150 151 152 165 166
    stmt <str> (111)
        on left: 137 138 139 140 141 142 143 144 145 146 147
        on right: 135 136
    range_comprehension <str> (112)
        on left: 148
        on right: 146
    arr_comprehension <str> (113)
        on left: 149
        on right: 147
    for_stmt <str> (114)
        on left: 150 151
        on right: 144
    while_stmt <str> (115)
        on left: 152
        on right: 143
    assign_stmt <str> (116)
        on left: 153 154 155 156 157 158 159
        on right: 145
    return_stmt <str> (117)
        on left: 160 161
        on right: 140
    break_stmt <str> (118)
        on left: 162
        on right: 60 141
    continue_stmt <str> (119)
        on left: 163
        on right: 61 142
    empty_stmt <str> (120)
        on left: 164
        on right: 56 137
    if_stmt <str> (121)
        on left: 165 166
        on right: 138
    func_call <str> (122)
        on left: 167
        on right: 127 139


State 0

    0 $accept: • input $end
    1 input: • comp_decl_rec const_decl_rec var_decl_rec func_decl_rec main_func
    8 comp_decl_rec: ε •
    9              | • comp_decl_rec comp_decl

    $default  reduce using rule 8 (comp_decl_rec)

    input          go to state 1
    comp_decl_rec  go to state 2


State 1

    0 $accept: input • $end

    $end  shift, and go to state 3


State 2

    1 input: comp_decl_rec • const_decl_rec var_decl_rec func_decl_rec main_func
    6 const_decl_rec: ε •  [KEYWORD_CONST, KEYWORD_DEF, IDENTIFIER]
    7               | • const_decl_rec const_decl
    9 comp_decl_rec: comp_decl_rec • comp_decl
   36 comp_decl: • KEYWORD_COMP IDENTIFIER COLON comp_var_decl_rec comp_func_decl_rec KEYWORD_ENDCOMP SEMICOLON

    KEYWORD_COMP  shift, and go to state 4

    $default  reduce using rule 6 (const_decl_rec)

    const_decl_rec  go to state 5
    comp_decl       go to state 6


State 3

    0 $accept: input $end •

    $default  accept


State 4

   36 comp_decl: KEYWORD_COMP • IDENTIFIER COLON comp_var_decl_rec comp_func_decl_rec KEYWORD_ENDCOMP SEMICOLON

    IDENTIFIER  shift, and go to state 7


State 5

    1 input: comp_decl_rec const_decl_rec • var_decl_rec func_decl_rec main_func
    4 var_decl_rec: ε •  [KEYWORD_DEF, IDENTIFIER]
    5             | • var_decl_rec var_decl
    7 const_decl_rec: const_decl_rec • const_decl
  106 const_decl: • KEYWORD_CONST IDENTIFIER ASSIGN expr COLON primitive_dt SEMICOLON

    KEYWORD_CONST  shift, and go to state 8

    $default  reduce using rule 4 (var_decl_rec)

    var_decl_rec  go to state 9
    const_decl    go to state 10


State 6

    9 comp_decl_rec: comp_decl_rec comp_decl •

    $default  reduce using rule 9 (comp_decl_rec)


State 7

   36 comp_decl: KEYWORD_COMP IDENTIFIER • COLON comp_var_decl_rec comp_func_decl_rec KEYWORD_ENDCOMP SEMICOLON

    COLON  shift, and go to state 11


State 8

  106 const_decl: KEYWORD_CONST • IDENTIFIER ASSIGN expr COLON primitive_dt SEMICOLON

    IDENTIFIER  shift, and go to state 12


State 9

    1 input: comp_decl_rec const_decl_rec var_decl_rec • func_decl_rec main_func
    2 func_decl_rec: ε •  [KEYWORD_DEF]
    3              | • func_decl_rec func_decl
    5 var_decl_rec: var_decl_rec • var_decl
   23 var_decl: • var_decl_list COLON var_type SEMICOLON
   24 var_decl_list: • var_name
   25              | • var_decl_list COMMA var_name
   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET

    IDENTIFIER  shift, and go to state 13

    $default  reduce using rule 2 (func_decl_rec)

    func_decl_rec  go to state 14
    var_decl       go to state 15
    var_decl_list  go to state 16
    var_name       go to state 17


State 10

    7 const_decl_rec: const_decl_rec const_decl •

    $default  reduce using rule 7 (const_decl_rec)


State 11

   36 comp_decl: KEYWORD_COMP IDENTIFIER COLON • comp_var_decl_rec comp_func_decl_rec KEYWORD_ENDCOMP SEMICOLON
   46 comp_var_decl_rec: • comp_var_decl
   47                  | • comp_var_decl_rec comp_var_decl
   48 comp_var_decl: • comp_var_decl_list COLON var_type SEMICOLON
   49 comp_var_decl_list: • comp_var_name_
   50                   | • comp_var_decl_list COMMA comp_var_name_
   51 comp_var_name_: • HASHTAG var_name

    HASHTAG  shift, and go to state 18

    comp_var_decl_rec   go to state 19
    comp_var_decl       go to state 20
    comp_var_decl_list  go to state 21
    comp_var_name_      go to state 22


State 12

  106 const_decl: KEYWORD_CONST IDENTIFIER • ASSIGN expr COLON primitive_dt SEMICOLON

    ASSIGN  shift, and go to state 23


State 13

   26 var_name: IDENTIFIER •  [KEYWORD_IN, KEYWORD_OF, ASSIGN, PLUS_ASSIGN, MINUS_ASSIGN, COLON_ASSIGN, MULT_ASSIGN, DIV_ASSIGN, MOD_ASSIGN, LPAREN, COMMA, COLON]
   27         | IDENTIFIER • LBRACKET expr RBRACKET

    LBRACKET  shift, and go to state 24

    $default  reduce using rule 26 (var_name)


State 14

    1 input: comp_decl_rec const_decl_rec var_decl_rec func_decl_rec • main_func
    3 func_decl_rec: func_decl_rec • func_decl
   10 main_func: • main_header func_body func_end
   11 main_header: • KEYWORD_DEF KEYWORD_MAIN LPAREN RPAREN COLON
   12 func_decl: • func_header func_body func_end
   13 func_header: • KEYWORD_DEF IDENTIFIER LPAREN func_param_list RPAREN COLON
   14            | • KEYWORD_DEF IDENTIFIER LPAREN func_param_list RPAREN MINUS GT var_type COLON

    KEYWORD_DEF  shift, and go to state 25

    main_func    go to state 26
    main_header  go to state 27
    func_decl    go to state 28
    func_header  go to state 29


State 15

    5 var_decl_rec: var_decl_rec var_decl •

    $default  reduce using rule 5 (var_decl_rec)


State 16

   23 var_decl: var_decl_list • COLON var_type SEMICOLON
   25 var_decl_list: var_decl_list • COMMA var_name

    COMMA  shift, and go to state 30
    COLON  shift, and go to state 31


State 17

   24 var_decl_list: var_name •

    $default  reduce using rule 24 (var_decl_list)


State 18

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   51 comp_var_name_: HASHTAG • var_name

    IDENTIFIER  shift, and go to state 13

    var_name  go to state 32


State 19

   36 comp_decl: KEYWORD_COMP IDENTIFIER COLON comp_var_decl_rec • comp_func_decl_rec KEYWORD_ENDCOMP SEMICOLON
   37 comp_func_decl_rec: ε •  [KEYWORD_DEF, KEYWORD_ENDCOMP]
   38                   | • comp_func_decl_rec comp_func_decl
   47 comp_var_decl_rec: comp_var_decl_rec • comp_var_decl
   48 comp_var_decl: • comp_var_decl_list COLON var_type SEMICOLON
   49 comp_var_decl_list: • comp_var_name_
   50                   | • comp_var_decl_list COMMA comp_var_name_
   51 comp_var_name_: • HASHTAG var_name

    HASHTAG  shift, and go to state 18

    $default  reduce using rule 37 (comp_func_decl_rec)

    comp_func_decl_rec  go to state 33
    comp_var_decl       go to state 34
    comp_var_decl_list  go to state 21
    comp_var_name_      go to state 22


State 20

   46 comp_var_decl_rec: comp_var_decl •

    $default  reduce using rule 46 (comp_var_decl_rec)


State 21

   48 comp_var_decl: comp_var_decl_list • COLON var_type SEMICOLON
   50 comp_var_decl_list: comp_var_decl_list • COMMA comp_var_name_

    COMMA  shift, and go to state 35
    COLON  shift, and go to state 36


State 22

   49 comp_var_decl_list: comp_var_name_ •

    $default  reduce using rule 49 (comp_var_decl_list)


State 23

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  106 const_decl: KEYWORD_CONST IDENTIFIER ASSIGN • expr COLON primitive_dt SEMICOLON
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 49
    operand    go to state 50
    func_call  go to state 51


State 24

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   27         | IDENTIFIER LBRACKET • expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 52
    operand    go to state 50
    func_call  go to state 51


State 25

   11 main_header: KEYWORD_DEF • KEYWORD_MAIN LPAREN RPAREN COLON
   13 func_header: KEYWORD_DEF • IDENTIFIER LPAREN func_param_list RPAREN COLON
   14            | KEYWORD_DEF • IDENTIFIER LPAREN func_param_list RPAREN MINUS GT var_type COLON

    KEYWORD_MAIN  shift, and go to state 53
    IDENTIFIER    shift, and go to state 54


State 26

    1 input: comp_decl_rec const_decl_rec var_decl_rec func_decl_rec main_func •

    $default  reduce using rule 1 (input)


State 27

    6 const_decl_rec: ε •
    7               | • const_decl_rec const_decl
   10 main_func: main_header • func_body func_end
   21 func_body: • const_decl_rec var_decl_rec stmts

    $default  reduce using rule 6 (const_decl_rec)

    const_decl_rec  go to state 55
    func_body       go to state 56


State 28

    3 func_decl_rec: func_decl_rec func_decl •

    $default  reduce using rule 3 (func_decl_rec)


State 29

    6 const_decl_rec: ε •
    7               | • const_decl_rec const_decl
   12 func_decl: func_header • func_body func_end
   21 func_body: • const_decl_rec var_decl_rec stmts

    $default  reduce using rule 6 (const_decl_rec)

    const_decl_rec  go to state 55
    func_body       go to state 57


State 30

   25 var_decl_list: var_decl_list COMMA • var_name
   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET

    IDENTIFIER  shift, and go to state 13

    var_name  go to state 58


State 31

   23 var_decl: var_decl_list COLON • var_type SEMICOLON
   28 var_type: • primitive_dt
   29         | • IDENTIFIER
   30 primitive_dt: • KEYWORD_SCALAR
   31             | • KEYWORD_INTEGER
   32             | • KEYWORD_STR
   33             | • KEYWORD_BOOL

    KEYWORD_SCALAR   shift, and go to state 59
    KEYWORD_STR      shift, and go to state 60
    KEYWORD_BOOL     shift, and go to state 61
    KEYWORD_INTEGER  shift, and go to state 62
    IDENTIFIER       shift, and go to state 63

    var_type      go to state 64
    primitive_dt  go to state 65


State 32

   51 comp_var_name_: HASHTAG var_name •

    $default  reduce using rule 51 (comp_var_name_)


State 33

   36 comp_decl: KEYWORD_COMP IDENTIFIER COLON comp_var_decl_rec comp_func_decl_rec • KEYWORD_ENDCOMP SEMICOLON
   38 comp_func_decl_rec: comp_func_decl_rec • comp_func_decl
   39 comp_func_decl: • comp_func_header comp_func_body func_end
   41 comp_func_header: • KEYWORD_DEF IDENTIFIER LPAREN comp_func_param_list RPAREN COLON
   42                 | • KEYWORD_DEF IDENTIFIER LPAREN comp_func_param_list RPAREN MINUS GT var_type COLON

    KEYWORD_DEF      shift, and go to state 66
    KEYWORD_ENDCOMP  shift, and go to state 67

    comp_func_decl    go to state 68
    comp_func_header  go to state 69


State 34

   47 comp_var_decl_rec: comp_var_decl_rec comp_var_decl •

    $default  reduce using rule 47 (comp_var_decl_rec)


State 35

   50 comp_var_decl_list: comp_var_decl_list COMMA • comp_var_name_
   51 comp_var_name_: • HASHTAG var_name

    HASHTAG  shift, and go to state 18

    comp_var_name_  go to state 70


State 36

   28 var_type: • primitive_dt
   29         | • IDENTIFIER
   30 primitive_dt: • KEYWORD_SCALAR
   31             | • KEYWORD_INTEGER
   32             | • KEYWORD_STR
   33             | • KEYWORD_BOOL
   48 comp_var_decl: comp_var_decl_list COLON • var_type SEMICOLON

    KEYWORD_SCALAR   shift, and go to state 59
    KEYWORD_STR      shift, and go to state 60
    KEYWORD_BOOL     shift, and go to state 61
    KEYWORD_INTEGER  shift, and go to state 62
    IDENTIFIER       shift, and go to state 63

    var_type      go to state 71
    primitive_dt  go to state 65


State 37

   34 bool_dt: KEYWORD_TRUE •

    $default  reduce using rule 34 (bool_dt)


State 38

   35 bool_dt: KEYWORD_FALSE •

    $default  reduce using rule 35 (bool_dt)


State 39

   26 var_name: IDENTIFIER •  [KEYWORD_FOR, SEMICOLON, ASSIGN, PLUS_ASSIGN, MINUS_ASSIGN, COLON_ASSIGN, MULT_ASSIGN, DIV_ASSIGN, MOD_ASSIGN, KEYWORD_OR, KEYWORD_AND, EQ, NEQ, LT, LEQ, GT, GEQ, PLUS, MINUS, MULT, DIV, MOD, POW, RBRACKET, RPAREN, COMMA, COLON]
   27         | IDENTIFIER • LBRACKET expr RBRACKET
  167 func_call: IDENTIFIER • LPAREN expr_list RPAREN

    LBRACKET  shift, and go to state 24
    LPAREN    shift, and go to state 72

    $default  reduce using rule 26 (var_name)


State 40

  128 operand: INTEGER •

    $default  reduce using rule 128 (operand)


State 41

  129 operand: FLOAT •

    $default  reduce using rule 129 (operand)


State 42

  131 operand: CONST_STRING •

    $default  reduce using rule 131 (operand)


State 43

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  121     | KEYWORD_NOT • expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 73
    operand    go to state 50
    func_call  go to state 51


State 44

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  122     | PLUS • expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 74
    operand    go to state 50
    func_call  go to state 51


State 45

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  123     | MINUS • expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 75
    operand    go to state 50
    func_call  go to state 51


State 46

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  125     | LPAREN • expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 76
    operand    go to state 50
    func_call  go to state 51


State 47

  126 operand: var_name •

    $default  reduce using rule 126 (operand)


State 48

  130 operand: bool_dt •

    $default  reduce using rule 130 (operand)


State 49

  106 const_decl: KEYWORD_CONST IDENTIFIER ASSIGN expr • COLON primitive_dt SEMICOLON
  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  124     | expr • POW expr

    KEYWORD_OR   shift, and go to state 77
    KEYWORD_AND  shift, and go to state 78
    EQ           shift, and go to state 79
    NEQ          shift, and go to state 80
    LT           shift, and go to state 81
    LEQ          shift, and go to state 82
    GT           shift, and go to state 83
    GEQ          shift, and go to state 84
    PLUS         shift, and go to state 85
    MINUS        shift, and go to state 86
    MULT         shift, and go to state 87
    DIV          shift, and go to state 88
    MOD          shift, and go to state 89
    POW          shift, and go to state 90
    COLON        shift, and go to state 91


State 50

  107 expr: operand •

    $default  reduce using rule 107 (expr)


State 51

  127 operand: func_call •

    $default  reduce using rule 127 (operand)


State 52

   27 var_name: IDENTIFIER LBRACKET expr • RBRACKET
  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  124     | expr • POW expr

    KEYWORD_OR   shift, and go to state 77
    KEYWORD_AND  shift, and go to state 78
    EQ           shift, and go to state 79
    NEQ          shift, and go to state 80
    LT           shift, and go to state 81
    LEQ          shift, and go to state 82
    GT           shift, and go to state 83
    GEQ          shift, and go to state 84
    PLUS         shift, and go to state 85
    MINUS        shift, and go to state 86
    MULT         shift, and go to state 87
    DIV          shift, and go to state 88
    MOD          shift, and go to state 89
    POW          shift, and go to state 90
    RBRACKET     shift, and go to state 92


State 53

   11 main_header: KEYWORD_DEF KEYWORD_MAIN • LPAREN RPAREN COLON

    LPAREN  shift, and go to state 93


State 54

   13 func_header: KEYWORD_DEF IDENTIFIER • LPAREN func_param_list RPAREN COLON
   14            | KEYWORD_DEF IDENTIFIER • LPAREN func_param_list RPAREN MINUS GT var_type COLON

    LPAREN  shift, and go to state 94


State 55

    4 var_decl_rec: ε •  [KEYWORD_IF, KEYWORD_FOR, KEYWORD_WHILE, KEYWORD_BREAK, KEYWORD_CONTINUE, KEYWORD_RETURN, IDENTIFIER, SEMICOLON]
    5             | • var_decl_rec var_decl
    7 const_decl_rec: const_decl_rec • const_decl
   21 func_body: const_decl_rec • var_decl_rec stmts
  106 const_decl: • KEYWORD_CONST IDENTIFIER ASSIGN expr COLON primitive_dt SEMICOLON

    KEYWORD_CONST  shift, and go to state 8

    $default  reduce using rule 4 (var_decl_rec)

    var_decl_rec  go to state 95
    const_decl    go to state 10


State 56

   10 main_func: main_header func_body • func_end
   22 func_end: • KEYWORD_ENDDEF SEMICOLON

    KEYWORD_ENDDEF  shift, and go to state 96

    func_end  go to state 97


State 57

   12 func_decl: func_header func_body • func_end
   22 func_end: • KEYWORD_ENDDEF SEMICOLON

    KEYWORD_ENDDEF  shift, and go to state 96

    func_end  go to state 98


State 58

   25 var_decl_list: var_decl_list COMMA var_name •

    $default  reduce using rule 25 (var_decl_list)


State 59

   30 primitive_dt: KEYWORD_SCALAR •

    $default  reduce using rule 30 (primitive_dt)


State 60

   32 primitive_dt: KEYWORD_STR •

    $default  reduce using rule 32 (primitive_dt)


State 61

   33 primitive_dt: KEYWORD_BOOL •

    $default  reduce using rule 33 (primitive_dt)


State 62

   31 primitive_dt: KEYWORD_INTEGER •

    $default  reduce using rule 31 (primitive_dt)


State 63

   29 var_type: IDENTIFIER •

    $default  reduce using rule 29 (var_type)


State 64

   23 var_decl: var_decl_list COLON var_type • SEMICOLON

    SEMICOLON  shift, and go to state 99


State 65

   28 var_type: primitive_dt •

    $default  reduce using rule 28 (var_type)


State 66

   41 comp_func_header: KEYWORD_DEF • IDENTIFIER LPAREN comp_func_param_list RPAREN COLON
   42                 | KEYWORD_DEF • IDENTIFIER LPAREN comp_func_param_list RPAREN MINUS GT var_type COLON

    IDENTIFIER  shift, and go to state 100


State 67

   36 comp_decl: KEYWORD_COMP IDENTIFIER COLON comp_var_decl_rec comp_func_decl_rec KEYWORD_ENDCOMP • SEMICOLON

    SEMICOLON  shift, and go to state 101


State 68

   38 comp_func_decl_rec: comp_func_decl_rec comp_func_decl •

    $default  reduce using rule 38 (comp_func_decl_rec)


State 69

    6 const_decl_rec: ε •
    7               | • const_decl_rec const_decl
   39 comp_func_decl: comp_func_header • comp_func_body func_end
   40 comp_func_body: • const_decl_rec var_decl_rec comp_stmts

    $default  reduce using rule 6 (const_decl_rec)

    const_decl_rec  go to state 102
    comp_func_body  go to state 103


State 70

   50 comp_var_decl_list: comp_var_decl_list COMMA comp_var_name_ •

    $default  reduce using rule 50 (comp_var_decl_list)


State 71

   48 comp_var_decl: comp_var_decl_list COLON var_type • SEMICOLON

    SEMICOLON  shift, and go to state 104


State 72

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  132 expr_list: ε •  [RPAREN, COMMA]
  133          | • expr
  134          | • expr_list COMMA expr
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN
  167          | IDENTIFIER LPAREN • expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    $default  reduce using rule 132 (expr_list)

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 105
    operand    go to state 50
    expr_list  go to state 106
    func_call  go to state 51


State 73

  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  121     | KEYWORD_NOT expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, KEYWORD_AND, RBRACKET, RPAREN, COMMA, COLON]
  124     | expr • POW expr

    EQ     shift, and go to state 79
    NEQ    shift, and go to state 80
    LT     shift, and go to state 81
    LEQ    shift, and go to state 82
    GT     shift, and go to state 83
    GEQ    shift, and go to state 84
    PLUS   shift, and go to state 85
    MINUS  shift, and go to state 86
    MULT   shift, and go to state 87
    DIV    shift, and go to state 88
    MOD    shift, and go to state 89
    POW    shift, and go to state 90

    $default  reduce using rule 121 (expr)

    Conflict between rule 121 and token KEYWORD_OR resolved as reduce (KEYWORD_OR < KEYWORD_NOT).
    Conflict between rule 121 and token KEYWORD_AND resolved as reduce (KEYWORD_AND < KEYWORD_NOT).
    Conflict between rule 121 and token EQ resolved as shift (KEYWORD_NOT < EQ).
    Conflict between rule 121 and token NEQ resolved as shift (KEYWORD_NOT < NEQ).
    Conflict between rule 121 and token LT resolved as shift (KEYWORD_NOT < LT).
    Conflict between rule 121 and token LEQ resolved as shift (KEYWORD_NOT < LEQ).
    Conflict between rule 121 and token GT resolved as shift (KEYWORD_NOT < GT).
    Conflict between rule 121 and token GEQ resolved as shift (KEYWORD_NOT < GEQ).
    Conflict between rule 121 and token PLUS resolved as shift (KEYWORD_NOT < PLUS).
    Conflict between rule 121 and token MINUS resolved as shift (KEYWORD_NOT < MINUS).
    Conflict between rule 121 and token MULT resolved as shift (KEYWORD_NOT < MULT).
    Conflict between rule 121 and token DIV resolved as shift (KEYWORD_NOT < DIV).
    Conflict between rule 121 and token MOD resolved as shift (KEYWORD_NOT < MOD).
    Conflict between rule 121 and token POW resolved as shift (KEYWORD_NOT < POW).


State 74

  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  122     | PLUS expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, KEYWORD_AND, EQ, NEQ, LT, LEQ, GT, GEQ, PLUS, RBRACKET, RPAREN, COMMA, COLON]
  124     | expr • POW expr

    MINUS  shift, and go to state 86
    MULT   shift, and go to state 87
    DIV    shift, and go to state 88
    MOD    shift, and go to state 89
    POW    shift, and go to state 90

    $default  reduce using rule 122 (expr)

    Conflict between rule 122 and token KEYWORD_OR resolved as reduce (KEYWORD_OR < PLUS).
    Conflict between rule 122 and token KEYWORD_AND resolved as reduce (KEYWORD_AND < PLUS).
    Conflict between rule 122 and token EQ resolved as reduce (EQ < PLUS).
    Conflict between rule 122 and token NEQ resolved as reduce (NEQ < PLUS).
    Conflict between rule 122 and token LT resolved as reduce (LT < PLUS).
    Conflict between rule 122 and token LEQ resolved as reduce (LEQ < PLUS).
    Conflict between rule 122 and token GT resolved as reduce (GT < PLUS).
    Conflict between rule 122 and token GEQ resolved as reduce (GEQ < PLUS).
    Conflict between rule 122 and token PLUS resolved as reduce (%left PLUS).
    Conflict between rule 122 and token MINUS resolved as shift (PLUS < MINUS).
    Conflict between rule 122 and token MULT resolved as shift (PLUS < MULT).
    Conflict between rule 122 and token DIV resolved as shift (PLUS < DIV).
    Conflict between rule 122 and token MOD resolved as shift (PLUS < MOD).
    Conflict between rule 122 and token POW resolved as shift (PLUS < POW).


State 75

  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  123     | MINUS expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, KEYWORD_AND, EQ, NEQ, LT, LEQ, GT, GEQ, PLUS, MINUS, RBRACKET, RPAREN, COMMA, COLON]
  124     | expr • POW expr

    MULT  shift, and go to state 87
    DIV   shift, and go to state 88
    MOD   shift, and go to state 89
    POW   shift, and go to state 90

    $default  reduce using rule 123 (expr)

    Conflict between rule 123 and token KEYWORD_OR resolved as reduce (KEYWORD_OR < MINUS).
    Conflict between rule 123 and token KEYWORD_AND resolved as reduce (KEYWORD_AND < MINUS).
    Conflict between rule 123 and token EQ resolved as reduce (EQ < MINUS).
    Conflict between rule 123 and token NEQ resolved as reduce (NEQ < MINUS).
    Conflict between rule 123 and token LT resolved as reduce (LT < MINUS).
    Conflict between rule 123 and token LEQ resolved as reduce (LEQ < MINUS).
    Conflict between rule 123 and token GT resolved as reduce (GT < MINUS).
    Conflict between rule 123 and token GEQ resolved as reduce (GEQ < MINUS).
    Conflict between rule 123 and token PLUS resolved as reduce (PLUS < MINUS).
    Conflict between rule 123 and token MINUS resolved as reduce (%left MINUS).
    Conflict between rule 123 and token MULT resolved as shift (MINUS < MULT).
    Conflict between rule 123 and token DIV resolved as shift (MINUS < DIV).
    Conflict between rule 123 and token MOD resolved as shift (MINUS < MOD).
    Conflict between rule 123 and token POW resolved as shift (MINUS < POW).


State 76

  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  124     | expr • POW expr
  125     | LPAREN expr • RPAREN

    KEYWORD_OR   shift, and go to state 77
    KEYWORD_AND  shift, and go to state 78
    EQ           shift, and go to state 79
    NEQ          shift, and go to state 80
    LT           shift, and go to state 81
    LEQ          shift, and go to state 82
    GT           shift, and go to state 83
    GEQ          shift, and go to state 84
    PLUS         shift, and go to state 85
    MINUS        shift, and go to state 86
    MULT         shift, and go to state 87
    DIV          shift, and go to state 88
    MOD          shift, and go to state 89
    POW          shift, and go to state 90
    RPAREN       shift, and go to state 107


State 77

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  120     | expr KEYWORD_OR • expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 108
    operand    go to state 50
    func_call  go to state 51


State 78

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  119     | expr KEYWORD_AND • expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 109
    operand    go to state 50
    func_call  go to state 51


State 79

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  117     | expr EQ • expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 110
    operand    go to state 50
    func_call  go to state 51


State 80

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  118     | expr NEQ • expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 111
    operand    go to state 50
    func_call  go to state 51


State 81

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  114     | expr LT • expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 112
    operand    go to state 50
    func_call  go to state 51


State 82

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  116     | expr LEQ • expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 113
    operand    go to state 50
    func_call  go to state 51


State 83

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  113     | expr GT • expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 114
    operand    go to state 50
    func_call  go to state 51


State 84

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  115     | expr GEQ • expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 115
    operand    go to state 50
    func_call  go to state 51


State 85

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  108     | expr PLUS • expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 116
    operand    go to state 50
    func_call  go to state 51


State 86

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  109     | expr MINUS • expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 117
    operand    go to state 50
    func_call  go to state 51


State 87

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  110     | expr MULT • expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 118
    operand    go to state 50
    func_call  go to state 51


State 88

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  111     | expr DIV • expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 119
    operand    go to state 50
    func_call  go to state 51


State 89

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  112     | expr MOD • expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 120
    operand    go to state 50
    func_call  go to state 51


State 90

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  124     | expr POW • expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 121
    operand    go to state 50
    func_call  go to state 51


State 91

   30 primitive_dt: • KEYWORD_SCALAR
   31             | • KEYWORD_INTEGER
   32             | • KEYWORD_STR
   33             | • KEYWORD_BOOL
  106 const_decl: KEYWORD_CONST IDENTIFIER ASSIGN expr COLON • primitive_dt SEMICOLON

    KEYWORD_SCALAR   shift, and go to state 59
    KEYWORD_STR      shift, and go to state 60
    KEYWORD_BOOL     shift, and go to state 61
    KEYWORD_INTEGER  shift, and go to state 62

    primitive_dt  go to state 122


State 92

   27 var_name: IDENTIFIER LBRACKET expr RBRACKET •

    $default  reduce using rule 27 (var_name)


State 93

   11 main_header: KEYWORD_DEF KEYWORD_MAIN LPAREN • RPAREN COLON

    RPAREN  shift, and go to state 123


State 94

   13 func_header: KEYWORD_DEF IDENTIFIER LPAREN • func_param_list RPAREN COLON
   14            | KEYWORD_DEF IDENTIFIER LPAREN • func_param_list RPAREN MINUS GT var_type COLON
   15 func_param_list: ε •  [RPAREN, COMMA]
   16                | • func_arg
   17                | • func_param_list COMMA func_arg
   18 func_arg: • func_arg_name COLON var_type
   19 func_arg_name: • IDENTIFIER
   20              | • IDENTIFIER LBRACKET RBRACKET

    IDENTIFIER  shift, and go to state 124

    $default  reduce using rule 15 (func_param_list)

    func_param_list  go to state 125
    func_arg         go to state 126
    func_arg_name    go to state 127


State 95

    5 var_decl_rec: var_decl_rec • var_decl
   21 func_body: const_decl_rec var_decl_rec • stmts
   23 var_decl: • var_decl_list COLON var_type SEMICOLON
   24 var_decl_list: • var_name
   25              | • var_decl_list COMMA var_name
   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
  135 stmts: • stmt
  136      | • stmts stmt
  137 stmt: • empty_stmt
  138     | • if_stmt
  139     | • func_call SEMICOLON
  140     | • return_stmt
  141     | • break_stmt
  142     | • continue_stmt
  143     | • while_stmt
  144     | • for_stmt
  145     | • assign_stmt
  146     | • range_comprehension
  147     | • arr_comprehension
  148 range_comprehension: • var_name COLON_ASSIGN LBRACKET expr KEYWORD_FOR var_name COLON INTEGER RBRACKET COLON var_type SEMICOLON
  149 arr_comprehension: • var_name COLON_ASSIGN LBRACKET expr KEYWORD_FOR var_name COLON var_type KEYWORD_IN var_name KEYWORD_OF INTEGER RBRACKET COLON var_type SEMICOLON
  150 for_stmt: • KEYWORD_FOR var_name KEYWORD_IN LBRACKET expr COLON expr COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON
  151         | • KEYWORD_FOR var_name KEYWORD_IN LBRACKET expr COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON
  152 while_stmt: • KEYWORD_WHILE LPAREN expr RPAREN COLON stmts KEYWORD_ENDWHILE SEMICOLON
  153 assign_stmt: • var_name ASSIGN expr SEMICOLON
  154            | • var_name PLUS_ASSIGN expr SEMICOLON
  155            | • var_name MINUS_ASSIGN expr SEMICOLON
  156            | • var_name MULT_ASSIGN expr SEMICOLON
  157            | • var_name DIV_ASSIGN expr SEMICOLON
  158            | • var_name MOD_ASSIGN expr SEMICOLON
  159            | • var_name COLON_ASSIGN expr SEMICOLON
  160 return_stmt: • KEYWORD_RETURN SEMICOLON
  161            | • KEYWORD_RETURN expr SEMICOLON
  162 break_stmt: • KEYWORD_BREAK SEMICOLON
  163 continue_stmt: • KEYWORD_CONTINUE SEMICOLON
  164 empty_stmt: • SEMICOLON
  165 if_stmt: • KEYWORD_IF LPAREN expr RPAREN COLON stmts KEYWORD_ENDIF SEMICOLON
  166        | • KEYWORD_IF LPAREN expr RPAREN COLON stmts KEYWORD_ELSE COLON stmts KEYWORD_ENDIF SEMICOLON
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_IF        shift, and go to state 128
    KEYWORD_FOR       shift, and go to state 129
    KEYWORD_WHILE     shift, and go to state 130
    KEYWORD_BREAK     shift, and go to state 131
    KEYWORD_CONTINUE  shift, and go to state 132
    KEYWORD_RETURN    shift, and go to state 133
    IDENTIFIER        shift, and go to state 39
    SEMICOLON         shift, and go to state 134

    var_decl             go to state 15
    var_decl_list        go to state 16
    var_name             go to state 135
    stmts                go to state 136
    stmt                 go to state 137
    range_comprehension  go to state 138
    arr_comprehension    go to state 139
    for_stmt             go to state 140
    while_stmt           go to state 141
    assign_stmt          go to state 142
    return_stmt          go to state 143
    break_stmt           go to state 144
    continue_stmt        go to state 145
    empty_stmt           go to state 146
    if_stmt              go to state 147
    func_call            go to state 148


State 96

   22 func_end: KEYWORD_ENDDEF • SEMICOLON

    SEMICOLON  shift, and go to state 149


State 97

   10 main_func: main_header func_body func_end •

    $default  reduce using rule 10 (main_func)


State 98

   12 func_decl: func_header func_body func_end •

    $default  reduce using rule 12 (func_decl)


State 99

   23 var_decl: var_decl_list COLON var_type SEMICOLON •

    $default  reduce using rule 23 (var_decl)


State 100

   41 comp_func_header: KEYWORD_DEF IDENTIFIER • LPAREN comp_func_param_list RPAREN COLON
   42                 | KEYWORD_DEF IDENTIFIER • LPAREN comp_func_param_list RPAREN MINUS GT var_type COLON

    LPAREN  shift, and go to state 150


State 101

   36 comp_decl: KEYWORD_COMP IDENTIFIER COLON comp_var_decl_rec comp_func_decl_rec KEYWORD_ENDCOMP SEMICOLON •

    $default  reduce using rule 36 (comp_decl)


State 102

    4 var_decl_rec: ε •  [KEYWORD_IF, KEYWORD_FOR, KEYWORD_WHILE, KEYWORD_BREAK, KEYWORD_CONTINUE, KEYWORD_RETURN, IDENTIFIER, HASHTAG, SEMICOLON]
    5             | • var_decl_rec var_decl
    7 const_decl_rec: const_decl_rec • const_decl
   40 comp_func_body: const_decl_rec • var_decl_rec comp_stmts
  106 const_decl: • KEYWORD_CONST IDENTIFIER ASSIGN expr COLON primitive_dt SEMICOLON

    KEYWORD_CONST  shift, and go to state 8

    $default  reduce using rule 4 (var_decl_rec)

    var_decl_rec  go to state 151
    const_decl    go to state 10


State 103

   22 func_end: • KEYWORD_ENDDEF SEMICOLON
   39 comp_func_decl: comp_func_header comp_func_body • func_end

    KEYWORD_ENDDEF  shift, and go to state 96

    func_end  go to state 152


State 104

   48 comp_var_decl: comp_var_decl_list COLON var_type SEMICOLON •

    $default  reduce using rule 48 (comp_var_decl)


State 105

  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  124     | expr • POW expr
  133 expr_list: expr •  [RPAREN, COMMA]

    KEYWORD_OR   shift, and go to state 77
    KEYWORD_AND  shift, and go to state 78
    EQ           shift, and go to state 79
    NEQ          shift, and go to state 80
    LT           shift, and go to state 81
    LEQ          shift, and go to state 82
    GT           shift, and go to state 83
    GEQ          shift, and go to state 84
    PLUS         shift, and go to state 85
    MINUS        shift, and go to state 86
    MULT         shift, and go to state 87
    DIV          shift, and go to state 88
    MOD          shift, and go to state 89
    POW          shift, and go to state 90

    $default  reduce using rule 133 (expr_list)


State 106

  134 expr_list: expr_list • COMMA expr
  167 func_call: IDENTIFIER LPAREN expr_list • RPAREN

    RPAREN  shift, and go to state 153
    COMMA   shift, and go to state 154


State 107

  125 expr: LPAREN expr RPAREN •

    $default  reduce using rule 125 (expr)


State 108

  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  120     | expr KEYWORD_OR expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, RBRACKET, RPAREN, COMMA, COLON]
  124     | expr • POW expr

    KEYWORD_AND  shift, and go to state 78
    EQ           shift, and go to state 79
    NEQ          shift, and go to state 80
    LT           shift, and go to state 81
    LEQ          shift, and go to state 82
    GT           shift, and go to state 83
    GEQ          shift, and go to state 84
    PLUS         shift, and go to state 85
    MINUS        shift, and go to state 86
    MULT         shift, and go to state 87
    DIV          shift, and go to state 88
    MOD          shift, and go to state 89
    POW          shift, and go to state 90

    $default  reduce using rule 120 (expr)

    Conflict between rule 120 and token KEYWORD_OR resolved as reduce (%left KEYWORD_OR).
    Conflict between rule 120 and token KEYWORD_AND resolved as shift (KEYWORD_OR < KEYWORD_AND).
    Conflict between rule 120 and token EQ resolved as shift (KEYWORD_OR < EQ).
    Conflict between rule 120 and token NEQ resolved as shift (KEYWORD_OR < NEQ).
    Conflict between rule 120 and token LT resolved as shift (KEYWORD_OR < LT).
    Conflict between rule 120 and token LEQ resolved as shift (KEYWORD_OR < LEQ).
    Conflict between rule 120 and token GT resolved as shift (KEYWORD_OR < GT).
    Conflict between rule 120 and token GEQ resolved as shift (KEYWORD_OR < GEQ).
    Conflict between rule 120 and token PLUS resolved as shift (KEYWORD_OR < PLUS).
    Conflict between rule 120 and token MINUS resolved as shift (KEYWORD_OR < MINUS).
    Conflict between rule 120 and token MULT resolved as shift (KEYWORD_OR < MULT).
    Conflict between rule 120 and token DIV resolved as shift (KEYWORD_OR < DIV).
    Conflict between rule 120 and token MOD resolved as shift (KEYWORD_OR < MOD).
    Conflict between rule 120 and token POW resolved as shift (KEYWORD_OR < POW).


State 109

  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  119     | expr KEYWORD_AND expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, KEYWORD_AND, RBRACKET, RPAREN, COMMA, COLON]
  120     | expr • KEYWORD_OR expr
  124     | expr • POW expr

    EQ     shift, and go to state 79
    NEQ    shift, and go to state 80
    LT     shift, and go to state 81
    LEQ    shift, and go to state 82
    GT     shift, and go to state 83
    GEQ    shift, and go to state 84
    PLUS   shift, and go to state 85
    MINUS  shift, and go to state 86
    MULT   shift, and go to state 87
    DIV    shift, and go to state 88
    MOD    shift, and go to state 89
    POW    shift, and go to state 90

    $default  reduce using rule 119 (expr)

    Conflict between rule 119 and token KEYWORD_OR resolved as reduce (KEYWORD_OR < KEYWORD_AND).
    Conflict between rule 119 and token KEYWORD_AND resolved as reduce (%left KEYWORD_AND).
    Conflict between rule 119 and token EQ resolved as shift (KEYWORD_AND < EQ).
    Conflict between rule 119 and token NEQ resolved as shift (KEYWORD_AND < NEQ).
    Conflict between rule 119 and token LT resolved as shift (KEYWORD_AND < LT).
    Conflict between rule 119 and token LEQ resolved as shift (KEYWORD_AND < LEQ).
    Conflict between rule 119 and token GT resolved as shift (KEYWORD_AND < GT).
    Conflict between rule 119 and token GEQ resolved as shift (KEYWORD_AND < GEQ).
    Conflict between rule 119 and token PLUS resolved as shift (KEYWORD_AND < PLUS).
    Conflict between rule 119 and token MINUS resolved as shift (KEYWORD_AND < MINUS).
    Conflict between rule 119 and token MULT resolved as shift (KEYWORD_AND < MULT).
    Conflict between rule 119 and token DIV resolved as shift (KEYWORD_AND < DIV).
    Conflict between rule 119 and token MOD resolved as shift (KEYWORD_AND < MOD).
    Conflict between rule 119 and token POW resolved as shift (KEYWORD_AND < POW).


State 110

  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  117     | expr EQ expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, KEYWORD_AND, EQ, RBRACKET, RPAREN, COMMA, COLON]
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  124     | expr • POW expr

    NEQ    shift, and go to state 80
    LT     shift, and go to state 81
    LEQ    shift, and go to state 82
    GT     shift, and go to state 83
    GEQ    shift, and go to state 84
    PLUS   shift, and go to state 85
    MINUS  shift, and go to state 86
    MULT   shift, and go to state 87
    DIV    shift, and go to state 88
    MOD    shift, and go to state 89
    POW    shift, and go to state 90

    $default  reduce using rule 117 (expr)

    Conflict between rule 117 and token KEYWORD_OR resolved as reduce (KEYWORD_OR < EQ).
    Conflict between rule 117 and token KEYWORD_AND resolved as reduce (KEYWORD_AND < EQ).
    Conflict between rule 117 and token EQ resolved as reduce (%left EQ).
    Conflict between rule 117 and token NEQ resolved as shift (EQ < NEQ).
    Conflict between rule 117 and token LT resolved as shift (EQ < LT).
    Conflict between rule 117 and token LEQ resolved as shift (EQ < LEQ).
    Conflict between rule 117 and token GT resolved as shift (EQ < GT).
    Conflict between rule 117 and token GEQ resolved as shift (EQ < GEQ).
    Conflict between rule 117 and token PLUS resolved as shift (EQ < PLUS).
    Conflict between rule 117 and token MINUS resolved as shift (EQ < MINUS).
    Conflict between rule 117 and token MULT resolved as shift (EQ < MULT).
    Conflict between rule 117 and token DIV resolved as shift (EQ < DIV).
    Conflict between rule 117 and token MOD resolved as shift (EQ < MOD).
    Conflict between rule 117 and token POW resolved as shift (EQ < POW).


State 111

  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  118     | expr NEQ expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, KEYWORD_AND, EQ, NEQ, RBRACKET, RPAREN, COMMA, COLON]
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  124     | expr • POW expr

    LT     shift, and go to state 81
    LEQ    shift, and go to state 82
    GT     shift, and go to state 83
    GEQ    shift, and go to state 84
    PLUS   shift, and go to state 85
    MINUS  shift, and go to state 86
    MULT   shift, and go to state 87
    DIV    shift, and go to state 88
    MOD    shift, and go to state 89
    POW    shift, and go to state 90

    $default  reduce using rule 118 (expr)

    Conflict between rule 118 and token KEYWORD_OR resolved as reduce (KEYWORD_OR < NEQ).
    Conflict between rule 118 and token KEYWORD_AND resolved as reduce (KEYWORD_AND < NEQ).
    Conflict between rule 118 and token EQ resolved as reduce (EQ < NEQ).
    Conflict between rule 118 and token NEQ resolved as reduce (%left NEQ).
    Conflict between rule 118 and token LT resolved as shift (NEQ < LT).
    Conflict between rule 118 and token LEQ resolved as shift (NEQ < LEQ).
    Conflict between rule 118 and token GT resolved as shift (NEQ < GT).
    Conflict between rule 118 and token GEQ resolved as shift (NEQ < GEQ).
    Conflict between rule 118 and token PLUS resolved as shift (NEQ < PLUS).
    Conflict between rule 118 and token MINUS resolved as shift (NEQ < MINUS).
    Conflict between rule 118 and token MULT resolved as shift (NEQ < MULT).
    Conflict between rule 118 and token DIV resolved as shift (NEQ < DIV).
    Conflict between rule 118 and token MOD resolved as shift (NEQ < MOD).
    Conflict between rule 118 and token POW resolved as shift (NEQ < POW).


State 112

  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  114     | expr LT expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, KEYWORD_AND, EQ, NEQ, LT, RBRACKET, RPAREN, COMMA, COLON]
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  124     | expr • POW expr

    LEQ    shift, and go to state 82
    GT     shift, and go to state 83
    GEQ    shift, and go to state 84
    PLUS   shift, and go to state 85
    MINUS  shift, and go to state 86
    MULT   shift, and go to state 87
    DIV    shift, and go to state 88
    MOD    shift, and go to state 89
    POW    shift, and go to state 90

    $default  reduce using rule 114 (expr)

    Conflict between rule 114 and token KEYWORD_OR resolved as reduce (KEYWORD_OR < LT).
    Conflict between rule 114 and token KEYWORD_AND resolved as reduce (KEYWORD_AND < LT).
    Conflict between rule 114 and token EQ resolved as reduce (EQ < LT).
    Conflict between rule 114 and token NEQ resolved as reduce (NEQ < LT).
    Conflict between rule 114 and token LT resolved as reduce (%left LT).
    Conflict between rule 114 and token LEQ resolved as shift (LT < LEQ).
    Conflict between rule 114 and token GT resolved as shift (LT < GT).
    Conflict between rule 114 and token GEQ resolved as shift (LT < GEQ).
    Conflict between rule 114 and token PLUS resolved as shift (LT < PLUS).
    Conflict between rule 114 and token MINUS resolved as shift (LT < MINUS).
    Conflict between rule 114 and token MULT resolved as shift (LT < MULT).
    Conflict between rule 114 and token DIV resolved as shift (LT < DIV).
    Conflict between rule 114 and token MOD resolved as shift (LT < MOD).
    Conflict between rule 114 and token POW resolved as shift (LT < POW).


State 113

  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  116     | expr LEQ expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, KEYWORD_AND, EQ, NEQ, LT, LEQ, RBRACKET, RPAREN, COMMA, COLON]
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  124     | expr • POW expr

    GT     shift, and go to state 83
    GEQ    shift, and go to state 84
    PLUS   shift, and go to state 85
    MINUS  shift, and go to state 86
    MULT   shift, and go to state 87
    DIV    shift, and go to state 88
    MOD    shift, and go to state 89
    POW    shift, and go to state 90

    $default  reduce using rule 116 (expr)

    Conflict between rule 116 and token KEYWORD_OR resolved as reduce (KEYWORD_OR < LEQ).
    Conflict between rule 116 and token KEYWORD_AND resolved as reduce (KEYWORD_AND < LEQ).
    Conflict between rule 116 and token EQ resolved as reduce (EQ < LEQ).
    Conflict between rule 116 and token NEQ resolved as reduce (NEQ < LEQ).
    Conflict between rule 116 and token LT resolved as reduce (LT < LEQ).
    Conflict between rule 116 and token LEQ resolved as reduce (%left LEQ).
    Conflict between rule 116 and token GT resolved as shift (LEQ < GT).
    Conflict between rule 116 and token GEQ resolved as shift (LEQ < GEQ).
    Conflict between rule 116 and token PLUS resolved as shift (LEQ < PLUS).
    Conflict between rule 116 and token MINUS resolved as shift (LEQ < MINUS).
    Conflict between rule 116 and token MULT resolved as shift (LEQ < MULT).
    Conflict between rule 116 and token DIV resolved as shift (LEQ < DIV).
    Conflict between rule 116 and token MOD resolved as shift (LEQ < MOD).
    Conflict between rule 116 and token POW resolved as shift (LEQ < POW).


State 114

  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  113     | expr GT expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, KEYWORD_AND, EQ, NEQ, LT, LEQ, GT, RBRACKET, RPAREN, COMMA, COLON]
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  124     | expr • POW expr

    GEQ    shift, and go to state 84
    PLUS   shift, and go to state 85
    MINUS  shift, and go to state 86
    MULT   shift, and go to state 87
    DIV    shift, and go to state 88
    MOD    shift, and go to state 89
    POW    shift, and go to state 90

    $default  reduce using rule 113 (expr)

    Conflict between rule 113 and token KEYWORD_OR resolved as reduce (KEYWORD_OR < GT).
    Conflict between rule 113 and token KEYWORD_AND resolved as reduce (KEYWORD_AND < GT).
    Conflict between rule 113 and token EQ resolved as reduce (EQ < GT).
    Conflict between rule 113 and token NEQ resolved as reduce (NEQ < GT).
    Conflict between rule 113 and token LT resolved as reduce (LT < GT).
    Conflict between rule 113 and token LEQ resolved as reduce (LEQ < GT).
    Conflict between rule 113 and token GT resolved as reduce (%left GT).
    Conflict between rule 113 and token GEQ resolved as shift (GT < GEQ).
    Conflict between rule 113 and token PLUS resolved as shift (GT < PLUS).
    Conflict between rule 113 and token MINUS resolved as shift (GT < MINUS).
    Conflict between rule 113 and token MULT resolved as shift (GT < MULT).
    Conflict between rule 113 and token DIV resolved as shift (GT < DIV).
    Conflict between rule 113 and token MOD resolved as shift (GT < MOD).
    Conflict between rule 113 and token POW resolved as shift (GT < POW).


State 115

  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  115     | expr GEQ expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, KEYWORD_AND, EQ, NEQ, LT, LEQ, GT, GEQ, RBRACKET, RPAREN, COMMA, COLON]
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  124     | expr • POW expr

    PLUS   shift, and go to state 85
    MINUS  shift, and go to state 86
    MULT   shift, and go to state 87
    DIV    shift, and go to state 88
    MOD    shift, and go to state 89
    POW    shift, and go to state 90

    $default  reduce using rule 115 (expr)

    Conflict between rule 115 and token KEYWORD_OR resolved as reduce (KEYWORD_OR < GEQ).
    Conflict between rule 115 and token KEYWORD_AND resolved as reduce (KEYWORD_AND < GEQ).
    Conflict between rule 115 and token EQ resolved as reduce (EQ < GEQ).
    Conflict between rule 115 and token NEQ resolved as reduce (NEQ < GEQ).
    Conflict between rule 115 and token LT resolved as reduce (LT < GEQ).
    Conflict between rule 115 and token LEQ resolved as reduce (LEQ < GEQ).
    Conflict between rule 115 and token GT resolved as reduce (GT < GEQ).
    Conflict between rule 115 and token GEQ resolved as reduce (%left GEQ).
    Conflict between rule 115 and token PLUS resolved as shift (GEQ < PLUS).
    Conflict between rule 115 and token MINUS resolved as shift (GEQ < MINUS).
    Conflict between rule 115 and token MULT resolved as shift (GEQ < MULT).
    Conflict between rule 115 and token DIV resolved as shift (GEQ < DIV).
    Conflict between rule 115 and token MOD resolved as shift (GEQ < MOD).
    Conflict between rule 115 and token POW resolved as shift (GEQ < POW).


State 116

  108 expr: expr • PLUS expr
  108     | expr PLUS expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, KEYWORD_AND, EQ, NEQ, LT, LEQ, GT, GEQ, PLUS, RBRACKET, RPAREN, COMMA, COLON]
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  124     | expr • POW expr

    MINUS  shift, and go to state 86
    MULT   shift, and go to state 87
    DIV    shift, and go to state 88
    MOD    shift, and go to state 89
    POW    shift, and go to state 90

    $default  reduce using rule 108 (expr)

    Conflict between rule 108 and token KEYWORD_OR resolved as reduce (KEYWORD_OR < PLUS).
    Conflict between rule 108 and token KEYWORD_AND resolved as reduce (KEYWORD_AND < PLUS).
    Conflict between rule 108 and token EQ resolved as reduce (EQ < PLUS).
    Conflict between rule 108 and token NEQ resolved as reduce (NEQ < PLUS).
    Conflict between rule 108 and token LT resolved as reduce (LT < PLUS).
    Conflict between rule 108 and token LEQ resolved as reduce (LEQ < PLUS).
    Conflict between rule 108 and token GT resolved as reduce (GT < PLUS).
    Conflict between rule 108 and token GEQ resolved as reduce (GEQ < PLUS).
    Conflict between rule 108 and token PLUS resolved as reduce (%left PLUS).
    Conflict between rule 108 and token MINUS resolved as shift (PLUS < MINUS).
    Conflict between rule 108 and token MULT resolved as shift (PLUS < MULT).
    Conflict between rule 108 and token DIV resolved as shift (PLUS < DIV).
    Conflict between rule 108 and token MOD resolved as shift (PLUS < MOD).
    Conflict between rule 108 and token POW resolved as shift (PLUS < POW).


State 117

  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  109     | expr MINUS expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, KEYWORD_AND, EQ, NEQ, LT, LEQ, GT, GEQ, PLUS, MINUS, RBRACKET, RPAREN, COMMA, COLON]
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  124     | expr • POW expr

    MULT  shift, and go to state 87
    DIV   shift, and go to state 88
    MOD   shift, and go to state 89
    POW   shift, and go to state 90

    $default  reduce using rule 109 (expr)

    Conflict between rule 109 and token KEYWORD_OR resolved as reduce (KEYWORD_OR < MINUS).
    Conflict between rule 109 and token KEYWORD_AND resolved as reduce (KEYWORD_AND < MINUS).
    Conflict between rule 109 and token EQ resolved as reduce (EQ < MINUS).
    Conflict between rule 109 and token NEQ resolved as reduce (NEQ < MINUS).
    Conflict between rule 109 and token LT resolved as reduce (LT < MINUS).
    Conflict between rule 109 and token LEQ resolved as reduce (LEQ < MINUS).
    Conflict between rule 109 and token GT resolved as reduce (GT < MINUS).
    Conflict between rule 109 and token GEQ resolved as reduce (GEQ < MINUS).
    Conflict between rule 109 and token PLUS resolved as reduce (PLUS < MINUS).
    Conflict between rule 109 and token MINUS resolved as reduce (%left MINUS).
    Conflict between rule 109 and token MULT resolved as shift (MINUS < MULT).
    Conflict between rule 109 and token DIV resolved as shift (MINUS < DIV).
    Conflict between rule 109 and token MOD resolved as shift (MINUS < MOD).
    Conflict between rule 109 and token POW resolved as shift (MINUS < POW).


State 118

  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  110     | expr MULT expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, KEYWORD_AND, EQ, NEQ, LT, LEQ, GT, GEQ, PLUS, MINUS, MULT, RBRACKET, RPAREN, COMMA, COLON]
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  124     | expr • POW expr

    DIV  shift, and go to state 88
    MOD  shift, and go to state 89
    POW  shift, and go to state 90

    $default  reduce using rule 110 (expr)

    Conflict between rule 110 and token KEYWORD_OR resolved as reduce (KEYWORD_OR < MULT).
    Conflict between rule 110 and token KEYWORD_AND resolved as reduce (KEYWORD_AND < MULT).
    Conflict between rule 110 and token EQ resolved as reduce (EQ < MULT).
    Conflict between rule 110 and token NEQ resolved as reduce (NEQ < MULT).
    Conflict between rule 110 and token LT resolved as reduce (LT < MULT).
    Conflict between rule 110 and token LEQ resolved as reduce (LEQ < MULT).
    Conflict between rule 110 and token GT resolved as reduce (GT < MULT).
    Conflict between rule 110 and token GEQ resolved as reduce (GEQ < MULT).
    Conflict between rule 110 and token PLUS resolved as reduce (PLUS < MULT).
    Conflict between rule 110 and token MINUS resolved as reduce (MINUS < MULT).
    Conflict between rule 110 and token MULT resolved as reduce (%left MULT).
    Conflict between rule 110 and token DIV resolved as shift (MULT < DIV).
    Conflict between rule 110 and token MOD resolved as shift (MULT < MOD).
    Conflict between rule 110 and token POW resolved as shift (MULT < POW).


State 119

  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  111     | expr DIV expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, KEYWORD_AND, EQ, NEQ, LT, LEQ, GT, GEQ, PLUS, MINUS, MULT, DIV, RBRACKET, RPAREN, COMMA, COLON]
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  124     | expr • POW expr

    MOD  shift, and go to state 89
    POW  shift, and go to state 90

    $default  reduce using rule 111 (expr)

    Conflict between rule 111 and token KEYWORD_OR resolved as reduce (KEYWORD_OR < DIV).
    Conflict between rule 111 and token KEYWORD_AND resolved as reduce (KEYWORD_AND < DIV).
    Conflict between rule 111 and token EQ resolved as reduce (EQ < DIV).
    Conflict between rule 111 and token NEQ resolved as reduce (NEQ < DIV).
    Conflict between rule 111 and token LT resolved as reduce (LT < DIV).
    Conflict between rule 111 and token LEQ resolved as reduce (LEQ < DIV).
    Conflict between rule 111 and token GT resolved as reduce (GT < DIV).
    Conflict between rule 111 and token GEQ resolved as reduce (GEQ < DIV).
    Conflict between rule 111 and token PLUS resolved as reduce (PLUS < DIV).
    Conflict between rule 111 and token MINUS resolved as reduce (MINUS < DIV).
    Conflict between rule 111 and token MULT resolved as reduce (MULT < DIV).
    Conflict between rule 111 and token DIV resolved as reduce (%left DIV).
    Conflict between rule 111 and token MOD resolved as shift (DIV < MOD).
    Conflict between rule 111 and token POW resolved as shift (DIV < POW).


State 120

  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  112     | expr MOD expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, KEYWORD_AND, EQ, NEQ, LT, LEQ, GT, GEQ, PLUS, MINUS, MULT, DIV, MOD, RBRACKET, RPAREN, COMMA, COLON]
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  124     | expr • POW expr

    POW  shift, and go to state 90

    $default  reduce using rule 112 (expr)

    Conflict between rule 112 and token KEYWORD_OR resolved as reduce (KEYWORD_OR < MOD).
    Conflict between rule 112 and token KEYWORD_AND resolved as reduce (KEYWORD_AND < MOD).
    Conflict between rule 112 and token EQ resolved as reduce (EQ < MOD).
    Conflict between rule 112 and token NEQ resolved as reduce (NEQ < MOD).
    Conflict between rule 112 and token LT resolved as reduce (LT < MOD).
    Conflict between rule 112 and token LEQ resolved as reduce (LEQ < MOD).
    Conflict between rule 112 and token GT resolved as reduce (GT < MOD).
    Conflict between rule 112 and token GEQ resolved as reduce (GEQ < MOD).
    Conflict between rule 112 and token PLUS resolved as reduce (PLUS < MOD).
    Conflict between rule 112 and token MINUS resolved as reduce (MINUS < MOD).
    Conflict between rule 112 and token MULT resolved as reduce (MULT < MOD).
    Conflict between rule 112 and token DIV resolved as reduce (DIV < MOD).
    Conflict between rule 112 and token MOD resolved as reduce (%left MOD).
    Conflict between rule 112 and token POW resolved as shift (MOD < POW).


State 121

  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  124     | expr • POW expr
  124     | expr POW expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, KEYWORD_AND, EQ, NEQ, LT, LEQ, GT, GEQ, PLUS, MINUS, MULT, DIV, MOD, RBRACKET, RPAREN, COMMA, COLON]

    POW  shift, and go to state 90

    $default  reduce using rule 124 (expr)

    Conflict between rule 124 and token KEYWORD_OR resolved as reduce (KEYWORD_OR < POW).
    Conflict between rule 124 and token KEYWORD_AND resolved as reduce (KEYWORD_AND < POW).
    Conflict between rule 124 and token EQ resolved as reduce (EQ < POW).
    Conflict between rule 124 and token NEQ resolved as reduce (NEQ < POW).
    Conflict between rule 124 and token LT resolved as reduce (LT < POW).
    Conflict between rule 124 and token LEQ resolved as reduce (LEQ < POW).
    Conflict between rule 124 and token GT resolved as reduce (GT < POW).
    Conflict between rule 124 and token GEQ resolved as reduce (GEQ < POW).
    Conflict between rule 124 and token PLUS resolved as reduce (PLUS < POW).
    Conflict between rule 124 and token MINUS resolved as reduce (MINUS < POW).
    Conflict between rule 124 and token MULT resolved as reduce (MULT < POW).
    Conflict between rule 124 and token DIV resolved as reduce (DIV < POW).
    Conflict between rule 124 and token MOD resolved as reduce (MOD < POW).
    Conflict between rule 124 and token POW resolved as shift (%right POW).


State 122

  106 const_decl: KEYWORD_CONST IDENTIFIER ASSIGN expr COLON primitive_dt • SEMICOLON

    SEMICOLON  shift, and go to state 155


State 123

   11 main_header: KEYWORD_DEF KEYWORD_MAIN LPAREN RPAREN • COLON

    COLON  shift, and go to state 156


State 124

   19 func_arg_name: IDENTIFIER •  [COLON]
   20              | IDENTIFIER • LBRACKET RBRACKET

    LBRACKET  shift, and go to state 157

    $default  reduce using rule 19 (func_arg_name)


State 125

   13 func_header: KEYWORD_DEF IDENTIFIER LPAREN func_param_list • RPAREN COLON
   14            | KEYWORD_DEF IDENTIFIER LPAREN func_param_list • RPAREN MINUS GT var_type COLON
   17 func_param_list: func_param_list • COMMA func_arg

    RPAREN  shift, and go to state 158
    COMMA   shift, and go to state 159


State 126

   16 func_param_list: func_arg •

    $default  reduce using rule 16 (func_param_list)


State 127

   18 func_arg: func_arg_name • COLON var_type

    COLON  shift, and go to state 160


State 128

  165 if_stmt: KEYWORD_IF • LPAREN expr RPAREN COLON stmts KEYWORD_ENDIF SEMICOLON
  166        | KEYWORD_IF • LPAREN expr RPAREN COLON stmts KEYWORD_ELSE COLON stmts KEYWORD_ENDIF SEMICOLON

    LPAREN  shift, and go to state 161


State 129

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
  150 for_stmt: KEYWORD_FOR • var_name KEYWORD_IN LBRACKET expr COLON expr COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON
  151         | KEYWORD_FOR • var_name KEYWORD_IN LBRACKET expr COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON

    IDENTIFIER  shift, and go to state 13

    var_name  go to state 162


State 130

  152 while_stmt: KEYWORD_WHILE • LPAREN expr RPAREN COLON stmts KEYWORD_ENDWHILE SEMICOLON

    LPAREN  shift, and go to state 163


State 131

  162 break_stmt: KEYWORD_BREAK • SEMICOLON

    SEMICOLON  shift, and go to state 164


State 132

  163 continue_stmt: KEYWORD_CONTINUE • SEMICOLON

    SEMICOLON  shift, and go to state 165


State 133

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  160 return_stmt: KEYWORD_RETURN • SEMICOLON
  161            | KEYWORD_RETURN • expr SEMICOLON
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    SEMICOLON      shift, and go to state 166
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 167
    operand    go to state 50
    func_call  go to state 51


State 134

  164 empty_stmt: SEMICOLON •

    $default  reduce using rule 164 (empty_stmt)


State 135

   24 var_decl_list: var_name •  [COMMA, COLON]
  148 range_comprehension: var_name • COLON_ASSIGN LBRACKET expr KEYWORD_FOR var_name COLON INTEGER RBRACKET COLON var_type SEMICOLON
  149 arr_comprehension: var_name • COLON_ASSIGN LBRACKET expr KEYWORD_FOR var_name COLON var_type KEYWORD_IN var_name KEYWORD_OF INTEGER RBRACKET COLON var_type SEMICOLON
  153 assign_stmt: var_name • ASSIGN expr SEMICOLON
  154            | var_name • PLUS_ASSIGN expr SEMICOLON
  155            | var_name • MINUS_ASSIGN expr SEMICOLON
  156            | var_name • MULT_ASSIGN expr SEMICOLON
  157            | var_name • DIV_ASSIGN expr SEMICOLON
  158            | var_name • MOD_ASSIGN expr SEMICOLON
  159            | var_name • COLON_ASSIGN expr SEMICOLON

    ASSIGN        shift, and go to state 168
    PLUS_ASSIGN   shift, and go to state 169
    MINUS_ASSIGN  shift, and go to state 170
    COLON_ASSIGN  shift, and go to state 171
    MULT_ASSIGN   shift, and go to state 172
    DIV_ASSIGN    shift, and go to state 173
    MOD_ASSIGN    shift, and go to state 174

    $default  reduce using rule 24 (var_decl_list)


State 136

   21 func_body: const_decl_rec var_decl_rec stmts •  [KEYWORD_ENDDEF]
   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
  136 stmts: stmts • stmt
  137 stmt: • empty_stmt
  138     | • if_stmt
  139     | • func_call SEMICOLON
  140     | • return_stmt
  141     | • break_stmt
  142     | • continue_stmt
  143     | • while_stmt
  144     | • for_stmt
  145     | • assign_stmt
  146     | • range_comprehension
  147     | • arr_comprehension
  148 range_comprehension: • var_name COLON_ASSIGN LBRACKET expr KEYWORD_FOR var_name COLON INTEGER RBRACKET COLON var_type SEMICOLON
  149 arr_comprehension: • var_name COLON_ASSIGN LBRACKET expr KEYWORD_FOR var_name COLON var_type KEYWORD_IN var_name KEYWORD_OF INTEGER RBRACKET COLON var_type SEMICOLON
  150 for_stmt: • KEYWORD_FOR var_name KEYWORD_IN LBRACKET expr COLON expr COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON
  151         | • KEYWORD_FOR var_name KEYWORD_IN LBRACKET expr COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON
  152 while_stmt: • KEYWORD_WHILE LPAREN expr RPAREN COLON stmts KEYWORD_ENDWHILE SEMICOLON
  153 assign_stmt: • var_name ASSIGN expr SEMICOLON
  154            | • var_name PLUS_ASSIGN expr SEMICOLON
  155            | • var_name MINUS_ASSIGN expr SEMICOLON
  156            | • var_name MULT_ASSIGN expr SEMICOLON
  157            | • var_name DIV_ASSIGN expr SEMICOLON
  158            | • var_name MOD_ASSIGN expr SEMICOLON
  159            | • var_name COLON_ASSIGN expr SEMICOLON
  160 return_stmt: • KEYWORD_RETURN SEMICOLON
  161            | • KEYWORD_RETURN expr SEMICOLON
  162 break_stmt: • KEYWORD_BREAK SEMICOLON
  163 continue_stmt: • KEYWORD_CONTINUE SEMICOLON
  164 empty_stmt: • SEMICOLON
  165 if_stmt: • KEYWORD_IF LPAREN expr RPAREN COLON stmts KEYWORD_ENDIF SEMICOLON
  166        | • KEYWORD_IF LPAREN expr RPAREN COLON stmts KEYWORD_ELSE COLON stmts KEYWORD_ENDIF SEMICOLON
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_IF        shift, and go to state 128
    KEYWORD_FOR       shift, and go to state 129
    KEYWORD_WHILE     shift, and go to state 130
    KEYWORD_BREAK     shift, and go to state 131
    KEYWORD_CONTINUE  shift, and go to state 132
    KEYWORD_RETURN    shift, and go to state 133
    IDENTIFIER        shift, and go to state 39
    SEMICOLON         shift, and go to state 134

    $default  reduce using rule 21 (func_body)

    var_name             go to state 175
    stmt                 go to state 176
    range_comprehension  go to state 138
    arr_comprehension    go to state 139
    for_stmt             go to state 140
    while_stmt           go to state 141
    assign_stmt          go to state 142
    return_stmt          go to state 143
    break_stmt           go to state 144
    continue_stmt        go to state 145
    empty_stmt           go to state 146
    if_stmt              go to state 147
    func_call            go to state 148


State 137

  135 stmts: stmt •

    $default  reduce using rule 135 (stmts)


State 138

  146 stmt: range_comprehension •

    $default  reduce using rule 146 (stmt)


State 139

  147 stmt: arr_comprehension •

    $default  reduce using rule 147 (stmt)


State 140

  144 stmt: for_stmt •

    $default  reduce using rule 144 (stmt)


State 141

  143 stmt: while_stmt •

    $default  reduce using rule 143 (stmt)


State 142

  145 stmt: assign_stmt •

    $default  reduce using rule 145 (stmt)


State 143

  140 stmt: return_stmt •

    $default  reduce using rule 140 (stmt)


State 144

  141 stmt: break_stmt •

    $default  reduce using rule 141 (stmt)


State 145

  142 stmt: continue_stmt •

    $default  reduce using rule 142 (stmt)


State 146

  137 stmt: empty_stmt •

    $default  reduce using rule 137 (stmt)


State 147

  138 stmt: if_stmt •

    $default  reduce using rule 138 (stmt)


State 148

  139 stmt: func_call • SEMICOLON

    SEMICOLON  shift, and go to state 177


State 149

   22 func_end: KEYWORD_ENDDEF SEMICOLON •

    $default  reduce using rule 22 (func_end)


State 150

   18 func_arg: • func_arg_name COLON var_type
   19 func_arg_name: • IDENTIFIER
   20              | • IDENTIFIER LBRACKET RBRACKET
   41 comp_func_header: KEYWORD_DEF IDENTIFIER LPAREN • comp_func_param_list RPAREN COLON
   42                 | KEYWORD_DEF IDENTIFIER LPAREN • comp_func_param_list RPAREN MINUS GT var_type COLON
   43 comp_func_param_list: ε •  [RPAREN, COMMA]
   44                     | • func_arg
   45                     | • comp_func_param_list COMMA func_arg

    IDENTIFIER  shift, and go to state 124

    $default  reduce using rule 43 (comp_func_param_list)

    func_arg              go to state 178
    func_arg_name         go to state 127
    comp_func_param_list  go to state 179


State 151

    5 var_decl_rec: var_decl_rec • var_decl
   23 var_decl: • var_decl_list COLON var_type SEMICOLON
   24 var_decl_list: • var_name
   25              | • var_decl_list COMMA var_name
   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   40 comp_func_body: const_decl_rec var_decl_rec • comp_stmts
   52 comp_var_name: • HASHTAG var_name
   53              | • var_name
   54 comp_stmts: • comp_stmt
   55           | • comp_stmts comp_stmt
   56 comp_stmt: • empty_stmt
   57          | • comp_if_stmt
   58          | • comp_func_call SEMICOLON
   59          | • comp_return_stmt
   60          | • break_stmt
   61          | • continue_stmt
   62          | • comp_while_stmt
   63          | • comp_for_stmt
   64          | • comp_assign_stmt
   65          | • comp_range_comprehension
   66          | • comp_arr_comprehension
   67 comp_range_comprehension: • comp_var_name COLON_ASSIGN LBRACKET comp_expr KEYWORD_FOR comp_var_name COLON INTEGER RBRACKET COLON var_type SEMICOLON
   68 comp_arr_comprehension: • comp_var_name COLON_ASSIGN LBRACKET comp_expr KEYWORD_FOR comp_var_name COLON var_type KEYWORD_IN comp_var_name KEYWORD_OF INTEGER RBRACKET COLON var_type SEMICOLON
   69 comp_for_stmt: • KEYWORD_FOR comp_var_name KEYWORD_IN LBRACKET comp_expr COLON comp_expr COLON comp_expr RBRACKET COLON comp_stmts KEYWORD_ENDFOR SEMICOLON
   70              | • KEYWORD_FOR comp_var_name KEYWORD_IN LBRACKET expr COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON
   71 comp_while_stmt: • KEYWORD_WHILE LPAREN comp_expr RPAREN COLON comp_stmts KEYWORD_ENDWHILE SEMICOLON
   72 comp_assign_stmt: • comp_var_name ASSIGN comp_expr SEMICOLON
   73                 | • comp_var_name PLUS_ASSIGN comp_expr SEMICOLON
   74                 | • comp_var_name MINUS_ASSIGN comp_expr SEMICOLON
   75                 | • comp_var_name MULT_ASSIGN comp_expr SEMICOLON
   76                 | • comp_var_name DIV_ASSIGN comp_expr SEMICOLON
   77                 | • comp_var_name MOD_ASSIGN comp_expr SEMICOLON
   78                 | • comp_var_name COLON_ASSIGN comp_expr SEMICOLON
   79 comp_return_stmt: • KEYWORD_RETURN SEMICOLON
   80                 | • KEYWORD_RETURN comp_expr SEMICOLON
   81 comp_if_stmt: • KEYWORD_IF LPAREN comp_expr RPAREN COLON comp_stmts KEYWORD_ENDIF SEMICOLON
   82             | • KEYWORD_IF LPAREN comp_expr RPAREN COLON comp_stmts KEYWORD_ELSE COLON comp_stmts KEYWORD_ENDIF SEMICOLON
   83 comp_func_call: • comp_var_name LPAREN comp_expr_list RPAREN
  162 break_stmt: • KEYWORD_BREAK SEMICOLON
  163 continue_stmt: • KEYWORD_CONTINUE SEMICOLON
  164 empty_stmt: • SEMICOLON

    KEYWORD_IF        shift, and go to state 180
    KEYWORD_FOR       shift, and go to state 181
    KEYWORD_WHILE     shift, and go to state 182
    KEYWORD_BREAK     shift, and go to state 131
    KEYWORD_CONTINUE  shift, and go to state 132
    KEYWORD_RETURN    shift, and go to state 183
    IDENTIFIER        shift, and go to state 13
    HASHTAG           shift, and go to state 184
    SEMICOLON         shift, and go to state 134

    var_decl                  go to state 15
    var_decl_list             go to state 16
    var_name                  go to state 185
    comp_var_name             go to state 186
    comp_stmts                go to state 187
    comp_stmt                 go to state 188
    comp_range_comprehension  go to state 189
    comp_arr_comprehension    go to state 190
    comp_for_stmt             go to state 191
    comp_while_stmt           go to state 192
    comp_assign_stmt          go to state 193
    comp_return_stmt          go to state 194
    comp_if_stmt              go to state 195
    comp_func_call            go to state 196
    break_stmt                go to state 197
    continue_stmt             go to state 198
    empty_stmt                go to state 199


State 152

   39 comp_func_decl: comp_func_header comp_func_body func_end •

    $default  reduce using rule 39 (comp_func_decl)


State 153

  167 func_call: IDENTIFIER LPAREN expr_list RPAREN •

    $default  reduce using rule 167 (func_call)


State 154

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  134 expr_list: expr_list COMMA • expr
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 200
    operand    go to state 50
    func_call  go to state 51


State 155

  106 const_decl: KEYWORD_CONST IDENTIFIER ASSIGN expr COLON primitive_dt SEMICOLON •

    $default  reduce using rule 106 (const_decl)


State 156

   11 main_header: KEYWORD_DEF KEYWORD_MAIN LPAREN RPAREN COLON •

    $default  reduce using rule 11 (main_header)


State 157

   20 func_arg_name: IDENTIFIER LBRACKET • RBRACKET

    RBRACKET  shift, and go to state 201


State 158

   13 func_header: KEYWORD_DEF IDENTIFIER LPAREN func_param_list RPAREN • COLON
   14            | KEYWORD_DEF IDENTIFIER LPAREN func_param_list RPAREN • MINUS GT var_type COLON

    MINUS  shift, and go to state 202
    COLON  shift, and go to state 203


State 159

   17 func_param_list: func_param_list COMMA • func_arg
   18 func_arg: • func_arg_name COLON var_type
   19 func_arg_name: • IDENTIFIER
   20              | • IDENTIFIER LBRACKET RBRACKET

    IDENTIFIER  shift, and go to state 124

    func_arg       go to state 204
    func_arg_name  go to state 127


State 160

   18 func_arg: func_arg_name COLON • var_type
   28 var_type: • primitive_dt
   29         | • IDENTIFIER
   30 primitive_dt: • KEYWORD_SCALAR
   31             | • KEYWORD_INTEGER
   32             | • KEYWORD_STR
   33             | • KEYWORD_BOOL

    KEYWORD_SCALAR   shift, and go to state 59
    KEYWORD_STR      shift, and go to state 60
    KEYWORD_BOOL     shift, and go to state 61
    KEYWORD_INTEGER  shift, and go to state 62
    IDENTIFIER       shift, and go to state 63

    var_type      go to state 205
    primitive_dt  go to state 65


State 161

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  165 if_stmt: KEYWORD_IF LPAREN • expr RPAREN COLON stmts KEYWORD_ENDIF SEMICOLON
  166        | KEYWORD_IF LPAREN • expr RPAREN COLON stmts KEYWORD_ELSE COLON stmts KEYWORD_ENDIF SEMICOLON
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 206
    operand    go to state 50
    func_call  go to state 51


State 162

  150 for_stmt: KEYWORD_FOR var_name • KEYWORD_IN LBRACKET expr COLON expr COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON
  151         | KEYWORD_FOR var_name • KEYWORD_IN LBRACKET expr COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON

    KEYWORD_IN  shift, and go to state 207


State 163

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  152 while_stmt: KEYWORD_WHILE LPAREN • expr RPAREN COLON stmts KEYWORD_ENDWHILE SEMICOLON
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 208
    operand    go to state 50
    func_call  go to state 51


State 164

  162 break_stmt: KEYWORD_BREAK SEMICOLON •

    $default  reduce using rule 162 (break_stmt)


State 165

  163 continue_stmt: KEYWORD_CONTINUE SEMICOLON •

    $default  reduce using rule 163 (continue_stmt)


State 166

  160 return_stmt: KEYWORD_RETURN SEMICOLON •

    $default  reduce using rule 160 (return_stmt)


State 167

  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  124     | expr • POW expr
  161 return_stmt: KEYWORD_RETURN expr • SEMICOLON

    SEMICOLON    shift, and go to state 209
    KEYWORD_OR   shift, and go to state 77
    KEYWORD_AND  shift, and go to state 78
    EQ           shift, and go to state 79
    NEQ          shift, and go to state 80
    LT           shift, and go to state 81
    LEQ          shift, and go to state 82
    GT           shift, and go to state 83
    GEQ          shift, and go to state 84
    PLUS         shift, and go to state 85
    MINUS        shift, and go to state 86
    MULT         shift, and go to state 87
    DIV          shift, and go to state 88
    MOD          shift, and go to state 89
    POW          shift, and go to state 90


State 168

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  153 assign_stmt: var_name ASSIGN • expr SEMICOLON
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 210
    operand    go to state 50
    func_call  go to state 51


State 169

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  154 assign_stmt: var_name PLUS_ASSIGN • expr SEMICOLON
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 211
    operand    go to state 50
    func_call  go to state 51


State 170

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  155 assign_stmt: var_name MINUS_ASSIGN • expr SEMICOLON
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 212
    operand    go to state 50
    func_call  go to state 51


State 171

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  148 range_comprehension: var_name COLON_ASSIGN • LBRACKET expr KEYWORD_FOR var_name COLON INTEGER RBRACKET COLON var_type SEMICOLON
  149 arr_comprehension: var_name COLON_ASSIGN • LBRACKET expr KEYWORD_FOR var_name COLON var_type KEYWORD_IN var_name KEYWORD_OF INTEGER RBRACKET COLON var_type SEMICOLON
  159 assign_stmt: var_name COLON_ASSIGN • expr SEMICOLON
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LBRACKET       shift, and go to state 213
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 214
    operand    go to state 50
    func_call  go to state 51


State 172

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  156 assign_stmt: var_name MULT_ASSIGN • expr SEMICOLON
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 215
    operand    go to state 50
    func_call  go to state 51


State 173

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  157 assign_stmt: var_name DIV_ASSIGN • expr SEMICOLON
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 216
    operand    go to state 50
    func_call  go to state 51


State 174

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  158 assign_stmt: var_name MOD_ASSIGN • expr SEMICOLON
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 217
    operand    go to state 50
    func_call  go to state 51


State 175

  148 range_comprehension: var_name • COLON_ASSIGN LBRACKET expr KEYWORD_FOR var_name COLON INTEGER RBRACKET COLON var_type SEMICOLON
  149 arr_comprehension: var_name • COLON_ASSIGN LBRACKET expr KEYWORD_FOR var_name COLON var_type KEYWORD_IN var_name KEYWORD_OF INTEGER RBRACKET COLON var_type SEMICOLON
  153 assign_stmt: var_name • ASSIGN expr SEMICOLON
  154            | var_name • PLUS_ASSIGN expr SEMICOLON
  155            | var_name • MINUS_ASSIGN expr SEMICOLON
  156            | var_name • MULT_ASSIGN expr SEMICOLON
  157            | var_name • DIV_ASSIGN expr SEMICOLON
  158            | var_name • MOD_ASSIGN expr SEMICOLON
  159            | var_name • COLON_ASSIGN expr SEMICOLON

    ASSIGN        shift, and go to state 168
    PLUS_ASSIGN   shift, and go to state 169
    MINUS_ASSIGN  shift, and go to state 170
    COLON_ASSIGN  shift, and go to state 171
    MULT_ASSIGN   shift, and go to state 172
    DIV_ASSIGN    shift, and go to state 173
    MOD_ASSIGN    shift, and go to state 174


State 176

  136 stmts: stmts stmt •

    $default  reduce using rule 136 (stmts)


State 177

  139 stmt: func_call SEMICOLON •

    $default  reduce using rule 139 (stmt)


State 178

   44 comp_func_param_list: func_arg •

    $default  reduce using rule 44 (comp_func_param_list)


State 179

   41 comp_func_header: KEYWORD_DEF IDENTIFIER LPAREN comp_func_param_list • RPAREN COLON
   42                 | KEYWORD_DEF IDENTIFIER LPAREN comp_func_param_list • RPAREN MINUS GT var_type COLON
   45 comp_func_param_list: comp_func_param_list • COMMA func_arg

    RPAREN  shift, and go to state 218
    COMMA   shift, and go to state 219


State 180

   81 comp_if_stmt: KEYWORD_IF • LPAREN comp_expr RPAREN COLON comp_stmts KEYWORD_ENDIF SEMICOLON
   82             | KEYWORD_IF • LPAREN comp_expr RPAREN COLON comp_stmts KEYWORD_ELSE COLON comp_stmts KEYWORD_ENDIF SEMICOLON

    LPAREN  shift, and go to state 220


State 181

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   52 comp_var_name: • HASHTAG var_name
   53              | • var_name
   69 comp_for_stmt: KEYWORD_FOR • comp_var_name KEYWORD_IN LBRACKET comp_expr COLON comp_expr COLON comp_expr RBRACKET COLON comp_stmts KEYWORD_ENDFOR SEMICOLON
   70              | KEYWORD_FOR • comp_var_name KEYWORD_IN LBRACKET expr COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON

    IDENTIFIER  shift, and go to state 13
    HASHTAG     shift, and go to state 184

    var_name       go to state 221
    comp_var_name  go to state 222


State 182

   71 comp_while_stmt: KEYWORD_WHILE • LPAREN comp_expr RPAREN COLON comp_stmts KEYWORD_ENDWHILE SEMICOLON

    LPAREN  shift, and go to state 223


State 183

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   79 comp_return_stmt: KEYWORD_RETURN • SEMICOLON
   80                 | KEYWORD_RETURN • comp_expr SEMICOLON
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    SEMICOLON      shift, and go to state 224
    KEYWORD_NOT    shift, and go to state 225
    PLUS           shift, and go to state 226
    MINUS          shift, and go to state 227
    LPAREN         shift, and go to state 228

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 229
    operand    go to state 230
    func_call  go to state 51


State 184

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   52 comp_var_name: HASHTAG • var_name

    IDENTIFIER  shift, and go to state 13

    var_name  go to state 231


State 185

   24 var_decl_list: var_name •  [COMMA, COLON]
   53 comp_var_name: var_name •  [ASSIGN, PLUS_ASSIGN, MINUS_ASSIGN, COLON_ASSIGN, MULT_ASSIGN, DIV_ASSIGN, MOD_ASSIGN, LPAREN]

    COMMA     reduce using rule 24 (var_decl_list)
    COLON     reduce using rule 24 (var_decl_list)
    $default  reduce using rule 53 (comp_var_name)


State 186

   67 comp_range_comprehension: comp_var_name • COLON_ASSIGN LBRACKET comp_expr KEYWORD_FOR comp_var_name COLON INTEGER RBRACKET COLON var_type SEMICOLON
   68 comp_arr_comprehension: comp_var_name • COLON_ASSIGN LBRACKET comp_expr KEYWORD_FOR comp_var_name COLON var_type KEYWORD_IN comp_var_name KEYWORD_OF INTEGER RBRACKET COLON var_type SEMICOLON
   72 comp_assign_stmt: comp_var_name • ASSIGN comp_expr SEMICOLON
   73                 | comp_var_name • PLUS_ASSIGN comp_expr SEMICOLON
   74                 | comp_var_name • MINUS_ASSIGN comp_expr SEMICOLON
   75                 | comp_var_name • MULT_ASSIGN comp_expr SEMICOLON
   76                 | comp_var_name • DIV_ASSIGN comp_expr SEMICOLON
   77                 | comp_var_name • MOD_ASSIGN comp_expr SEMICOLON
   78                 | comp_var_name • COLON_ASSIGN comp_expr SEMICOLON
   83 comp_func_call: comp_var_name • LPAREN comp_expr_list RPAREN

    ASSIGN        shift, and go to state 232
    PLUS_ASSIGN   shift, and go to state 233
    MINUS_ASSIGN  shift, and go to state 234
    COLON_ASSIGN  shift, and go to state 235
    MULT_ASSIGN   shift, and go to state 236
    DIV_ASSIGN    shift, and go to state 237
    MOD_ASSIGN    shift, and go to state 238
    LPAREN        shift, and go to state 239


State 187

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   40 comp_func_body: const_decl_rec var_decl_rec comp_stmts •  [KEYWORD_ENDDEF]
   52 comp_var_name: • HASHTAG var_name
   53              | • var_name
   55 comp_stmts: comp_stmts • comp_stmt
   56 comp_stmt: • empty_stmt
   57          | • comp_if_stmt
   58          | • comp_func_call SEMICOLON
   59          | • comp_return_stmt
   60          | • break_stmt
   61          | • continue_stmt
   62          | • comp_while_stmt
   63          | • comp_for_stmt
   64          | • comp_assign_stmt
   65          | • comp_range_comprehension
   66          | • comp_arr_comprehension
   67 comp_range_comprehension: • comp_var_name COLON_ASSIGN LBRACKET comp_expr KEYWORD_FOR comp_var_name COLON INTEGER RBRACKET COLON var_type SEMICOLON
   68 comp_arr_comprehension: • comp_var_name COLON_ASSIGN LBRACKET comp_expr KEYWORD_FOR comp_var_name COLON var_type KEYWORD_IN comp_var_name KEYWORD_OF INTEGER RBRACKET COLON var_type SEMICOLON
   69 comp_for_stmt: • KEYWORD_FOR comp_var_name KEYWORD_IN LBRACKET comp_expr COLON comp_expr COLON comp_expr RBRACKET COLON comp_stmts KEYWORD_ENDFOR SEMICOLON
   70              | • KEYWORD_FOR comp_var_name KEYWORD_IN LBRACKET expr COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON
   71 comp_while_stmt: • KEYWORD_WHILE LPAREN comp_expr RPAREN COLON comp_stmts KEYWORD_ENDWHILE SEMICOLON
   72 comp_assign_stmt: • comp_var_name ASSIGN comp_expr SEMICOLON
   73                 | • comp_var_name PLUS_ASSIGN comp_expr SEMICOLON
   74                 | • comp_var_name MINUS_ASSIGN comp_expr SEMICOLON
   75                 | • comp_var_name MULT_ASSIGN comp_expr SEMICOLON
   76                 | • comp_var_name DIV_ASSIGN comp_expr SEMICOLON
   77                 | • comp_var_name MOD_ASSIGN comp_expr SEMICOLON
   78                 | • comp_var_name COLON_ASSIGN comp_expr SEMICOLON
   79 comp_return_stmt: • KEYWORD_RETURN SEMICOLON
   80                 | • KEYWORD_RETURN comp_expr SEMICOLON
   81 comp_if_stmt: • KEYWORD_IF LPAREN comp_expr RPAREN COLON comp_stmts KEYWORD_ENDIF SEMICOLON
   82             | • KEYWORD_IF LPAREN comp_expr RPAREN COLON comp_stmts KEYWORD_ELSE COLON comp_stmts KEYWORD_ENDIF SEMICOLON
   83 comp_func_call: • comp_var_name LPAREN comp_expr_list RPAREN
  162 break_stmt: • KEYWORD_BREAK SEMICOLON
  163 continue_stmt: • KEYWORD_CONTINUE SEMICOLON
  164 empty_stmt: • SEMICOLON

    KEYWORD_IF        shift, and go to state 180
    KEYWORD_FOR       shift, and go to state 181
    KEYWORD_WHILE     shift, and go to state 182
    KEYWORD_BREAK     shift, and go to state 131
    KEYWORD_CONTINUE  shift, and go to state 132
    KEYWORD_RETURN    shift, and go to state 183
    IDENTIFIER        shift, and go to state 13
    HASHTAG           shift, and go to state 184
    SEMICOLON         shift, and go to state 134

    $default  reduce using rule 40 (comp_func_body)

    var_name                  go to state 221
    comp_var_name             go to state 186
    comp_stmt                 go to state 240
    comp_range_comprehension  go to state 189
    comp_arr_comprehension    go to state 190
    comp_for_stmt             go to state 191
    comp_while_stmt           go to state 192
    comp_assign_stmt          go to state 193
    comp_return_stmt          go to state 194
    comp_if_stmt              go to state 195
    comp_func_call            go to state 196
    break_stmt                go to state 197
    continue_stmt             go to state 198
    empty_stmt                go to state 199


State 188

   54 comp_stmts: comp_stmt •

    $default  reduce using rule 54 (comp_stmts)


State 189

   65 comp_stmt: comp_range_comprehension •

    $default  reduce using rule 65 (comp_stmt)


State 190

   66 comp_stmt: comp_arr_comprehension •

    $default  reduce using rule 66 (comp_stmt)


State 191

   63 comp_stmt: comp_for_stmt •

    $default  reduce using rule 63 (comp_stmt)


State 192

   62 comp_stmt: comp_while_stmt •

    $default  reduce using rule 62 (comp_stmt)


State 193

   64 comp_stmt: comp_assign_stmt •

    $default  reduce using rule 64 (comp_stmt)


State 194

   59 comp_stmt: comp_return_stmt •

    $default  reduce using rule 59 (comp_stmt)


State 195

   57 comp_stmt: comp_if_stmt •

    $default  reduce using rule 57 (comp_stmt)


State 196

   58 comp_stmt: comp_func_call • SEMICOLON

    SEMICOLON  shift, and go to state 241


State 197

   60 comp_stmt: break_stmt •

    $default  reduce using rule 60 (comp_stmt)


State 198

   61 comp_stmt: continue_stmt •

    $default  reduce using rule 61 (comp_stmt)


State 199

   56 comp_stmt: empty_stmt •

    $default  reduce using rule 56 (comp_stmt)


State 200

  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  124     | expr • POW expr
  134 expr_list: expr_list COMMA expr •  [RPAREN, COMMA]

    KEYWORD_OR   shift, and go to state 77
    KEYWORD_AND  shift, and go to state 78
    EQ           shift, and go to state 79
    NEQ          shift, and go to state 80
    LT           shift, and go to state 81
    LEQ          shift, and go to state 82
    GT           shift, and go to state 83
    GEQ          shift, and go to state 84
    PLUS         shift, and go to state 85
    MINUS        shift, and go to state 86
    MULT         shift, and go to state 87
    DIV          shift, and go to state 88
    MOD          shift, and go to state 89
    POW          shift, and go to state 90

    $default  reduce using rule 134 (expr_list)


State 201

   20 func_arg_name: IDENTIFIER LBRACKET RBRACKET •

    $default  reduce using rule 20 (func_arg_name)


State 202

   14 func_header: KEYWORD_DEF IDENTIFIER LPAREN func_param_list RPAREN MINUS • GT var_type COLON

    GT  shift, and go to state 242


State 203

   13 func_header: KEYWORD_DEF IDENTIFIER LPAREN func_param_list RPAREN COLON •

    $default  reduce using rule 13 (func_header)


State 204

   17 func_param_list: func_param_list COMMA func_arg •

    $default  reduce using rule 17 (func_param_list)


State 205

   18 func_arg: func_arg_name COLON var_type •

    $default  reduce using rule 18 (func_arg)


State 206

  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  124     | expr • POW expr
  165 if_stmt: KEYWORD_IF LPAREN expr • RPAREN COLON stmts KEYWORD_ENDIF SEMICOLON
  166        | KEYWORD_IF LPAREN expr • RPAREN COLON stmts KEYWORD_ELSE COLON stmts KEYWORD_ENDIF SEMICOLON

    KEYWORD_OR   shift, and go to state 77
    KEYWORD_AND  shift, and go to state 78
    EQ           shift, and go to state 79
    NEQ          shift, and go to state 80
    LT           shift, and go to state 81
    LEQ          shift, and go to state 82
    GT           shift, and go to state 83
    GEQ          shift, and go to state 84
    PLUS         shift, and go to state 85
    MINUS        shift, and go to state 86
    MULT         shift, and go to state 87
    DIV          shift, and go to state 88
    MOD          shift, and go to state 89
    POW          shift, and go to state 90
    RPAREN       shift, and go to state 243


State 207

  150 for_stmt: KEYWORD_FOR var_name KEYWORD_IN • LBRACKET expr COLON expr COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON
  151         | KEYWORD_FOR var_name KEYWORD_IN • LBRACKET expr COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON

    LBRACKET  shift, and go to state 244


State 208

  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  124     | expr • POW expr
  152 while_stmt: KEYWORD_WHILE LPAREN expr • RPAREN COLON stmts KEYWORD_ENDWHILE SEMICOLON

    KEYWORD_OR   shift, and go to state 77
    KEYWORD_AND  shift, and go to state 78
    EQ           shift, and go to state 79
    NEQ          shift, and go to state 80
    LT           shift, and go to state 81
    LEQ          shift, and go to state 82
    GT           shift, and go to state 83
    GEQ          shift, and go to state 84
    PLUS         shift, and go to state 85
    MINUS        shift, and go to state 86
    MULT         shift, and go to state 87
    DIV          shift, and go to state 88
    MOD          shift, and go to state 89
    POW          shift, and go to state 90
    RPAREN       shift, and go to state 245


State 209

  161 return_stmt: KEYWORD_RETURN expr SEMICOLON •

    $default  reduce using rule 161 (return_stmt)


State 210

  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  124     | expr • POW expr
  153 assign_stmt: var_name ASSIGN expr • SEMICOLON

    SEMICOLON    shift, and go to state 246
    KEYWORD_OR   shift, and go to state 77
    KEYWORD_AND  shift, and go to state 78
    EQ           shift, and go to state 79
    NEQ          shift, and go to state 80
    LT           shift, and go to state 81
    LEQ          shift, and go to state 82
    GT           shift, and go to state 83
    GEQ          shift, and go to state 84
    PLUS         shift, and go to state 85
    MINUS        shift, and go to state 86
    MULT         shift, and go to state 87
    DIV          shift, and go to state 88
    MOD          shift, and go to state 89
    POW          shift, and go to state 90


State 211

  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  124     | expr • POW expr
  154 assign_stmt: var_name PLUS_ASSIGN expr • SEMICOLON

    SEMICOLON    shift, and go to state 247
    KEYWORD_OR   shift, and go to state 77
    KEYWORD_AND  shift, and go to state 78
    EQ           shift, and go to state 79
    NEQ          shift, and go to state 80
    LT           shift, and go to state 81
    LEQ          shift, and go to state 82
    GT           shift, and go to state 83
    GEQ          shift, and go to state 84
    PLUS         shift, and go to state 85
    MINUS        shift, and go to state 86
    MULT         shift, and go to state 87
    DIV          shift, and go to state 88
    MOD          shift, and go to state 89
    POW          shift, and go to state 90


State 212

  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  124     | expr • POW expr
  155 assign_stmt: var_name MINUS_ASSIGN expr • SEMICOLON

    SEMICOLON    shift, and go to state 248
    KEYWORD_OR   shift, and go to state 77
    KEYWORD_AND  shift, and go to state 78
    EQ           shift, and go to state 79
    NEQ          shift, and go to state 80
    LT           shift, and go to state 81
    LEQ          shift, and go to state 82
    GT           shift, and go to state 83
    GEQ          shift, and go to state 84
    PLUS         shift, and go to state 85
    MINUS        shift, and go to state 86
    MULT         shift, and go to state 87
    DIV          shift, and go to state 88
    MOD          shift, and go to state 89
    POW          shift, and go to state 90


State 213

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  148 range_comprehension: var_name COLON_ASSIGN LBRACKET • expr KEYWORD_FOR var_name COLON INTEGER RBRACKET COLON var_type SEMICOLON
  149 arr_comprehension: var_name COLON_ASSIGN LBRACKET • expr KEYWORD_FOR var_name COLON var_type KEYWORD_IN var_name KEYWORD_OF INTEGER RBRACKET COLON var_type SEMICOLON
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 249
    operand    go to state 50
    func_call  go to state 51


State 214

  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  124     | expr • POW expr
  159 assign_stmt: var_name COLON_ASSIGN expr • SEMICOLON

    SEMICOLON    shift, and go to state 250
    KEYWORD_OR   shift, and go to state 77
    KEYWORD_AND  shift, and go to state 78
    EQ           shift, and go to state 79
    NEQ          shift, and go to state 80
    LT           shift, and go to state 81
    LEQ          shift, and go to state 82
    GT           shift, and go to state 83
    GEQ          shift, and go to state 84
    PLUS         shift, and go to state 85
    MINUS        shift, and go to state 86
    MULT         shift, and go to state 87
    DIV          shift, and go to state 88
    MOD          shift, and go to state 89
    POW          shift, and go to state 90


State 215

  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  124     | expr • POW expr
  156 assign_stmt: var_name MULT_ASSIGN expr • SEMICOLON

    SEMICOLON    shift, and go to state 251
    KEYWORD_OR   shift, and go to state 77
    KEYWORD_AND  shift, and go to state 78
    EQ           shift, and go to state 79
    NEQ          shift, and go to state 80
    LT           shift, and go to state 81
    LEQ          shift, and go to state 82
    GT           shift, and go to state 83
    GEQ          shift, and go to state 84
    PLUS         shift, and go to state 85
    MINUS        shift, and go to state 86
    MULT         shift, and go to state 87
    DIV          shift, and go to state 88
    MOD          shift, and go to state 89
    POW          shift, and go to state 90


State 216

  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  124     | expr • POW expr
  157 assign_stmt: var_name DIV_ASSIGN expr • SEMICOLON

    SEMICOLON    shift, and go to state 252
    KEYWORD_OR   shift, and go to state 77
    KEYWORD_AND  shift, and go to state 78
    EQ           shift, and go to state 79
    NEQ          shift, and go to state 80
    LT           shift, and go to state 81
    LEQ          shift, and go to state 82
    GT           shift, and go to state 83
    GEQ          shift, and go to state 84
    PLUS         shift, and go to state 85
    MINUS        shift, and go to state 86
    MULT         shift, and go to state 87
    DIV          shift, and go to state 88
    MOD          shift, and go to state 89
    POW          shift, and go to state 90


State 217

  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  124     | expr • POW expr
  158 assign_stmt: var_name MOD_ASSIGN expr • SEMICOLON

    SEMICOLON    shift, and go to state 253
    KEYWORD_OR   shift, and go to state 77
    KEYWORD_AND  shift, and go to state 78
    EQ           shift, and go to state 79
    NEQ          shift, and go to state 80
    LT           shift, and go to state 81
    LEQ          shift, and go to state 82
    GT           shift, and go to state 83
    GEQ          shift, and go to state 84
    PLUS         shift, and go to state 85
    MINUS        shift, and go to state 86
    MULT         shift, and go to state 87
    DIV          shift, and go to state 88
    MOD          shift, and go to state 89
    POW          shift, and go to state 90


State 218

   41 comp_func_header: KEYWORD_DEF IDENTIFIER LPAREN comp_func_param_list RPAREN • COLON
   42                 | KEYWORD_DEF IDENTIFIER LPAREN comp_func_param_list RPAREN • MINUS GT var_type COLON

    MINUS  shift, and go to state 254
    COLON  shift, and go to state 255


State 219

   18 func_arg: • func_arg_name COLON var_type
   19 func_arg_name: • IDENTIFIER
   20              | • IDENTIFIER LBRACKET RBRACKET
   45 comp_func_param_list: comp_func_param_list COMMA • func_arg

    IDENTIFIER  shift, and go to state 124

    func_arg       go to state 256
    func_arg_name  go to state 127


State 220

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   81 comp_if_stmt: KEYWORD_IF LPAREN • comp_expr RPAREN COLON comp_stmts KEYWORD_ENDIF SEMICOLON
   82             | KEYWORD_IF LPAREN • comp_expr RPAREN COLON comp_stmts KEYWORD_ELSE COLON comp_stmts KEYWORD_ENDIF SEMICOLON
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 225
    PLUS           shift, and go to state 226
    MINUS          shift, and go to state 227
    LPAREN         shift, and go to state 228

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 257
    operand    go to state 230
    func_call  go to state 51


State 221

   53 comp_var_name: var_name •

    $default  reduce using rule 53 (comp_var_name)


State 222

   69 comp_for_stmt: KEYWORD_FOR comp_var_name • KEYWORD_IN LBRACKET comp_expr COLON comp_expr COLON comp_expr RBRACKET COLON comp_stmts KEYWORD_ENDFOR SEMICOLON
   70              | KEYWORD_FOR comp_var_name • KEYWORD_IN LBRACKET expr COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON

    KEYWORD_IN  shift, and go to state 258


State 223

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   71 comp_while_stmt: KEYWORD_WHILE LPAREN • comp_expr RPAREN COLON comp_stmts KEYWORD_ENDWHILE SEMICOLON
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 225
    PLUS           shift, and go to state 226
    MINUS          shift, and go to state 227
    LPAREN         shift, and go to state 228

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 259
    operand    go to state 230
    func_call  go to state 51


State 224

   79 comp_return_stmt: KEYWORD_RETURN SEMICOLON •

    $default  reduce using rule 79 (comp_return_stmt)


State 225

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  101          | KEYWORD_NOT • comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 225
    PLUS           shift, and go to state 226
    MINUS          shift, and go to state 227
    LPAREN         shift, and go to state 228

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 260
    operand    go to state 230
    func_call  go to state 51


State 226

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  102          | PLUS • comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 225
    PLUS           shift, and go to state 226
    MINUS          shift, and go to state 227
    LPAREN         shift, and go to state 228

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 261
    operand    go to state 230
    func_call  go to state 51


State 227

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  103          | MINUS • comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 225
    PLUS           shift, and go to state 226
    MINUS          shift, and go to state 227
    LPAREN         shift, and go to state 228

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 262
    operand    go to state 230
    func_call  go to state 51


State 228

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  105          | LPAREN • comp_expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 225
    PLUS           shift, and go to state 226
    MINUS          shift, and go to state 227
    LPAREN         shift, and go to state 228

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 263
    operand    go to state 230
    func_call  go to state 51


State 229

   80 comp_return_stmt: KEYWORD_RETURN comp_expr • SEMICOLON
   88 comp_expr: comp_expr • PLUS comp_expr
   89          | comp_expr • MINUS comp_expr
   90          | comp_expr • MULT comp_expr
   91          | comp_expr • DIV comp_expr
   92          | comp_expr • MOD comp_expr
   93          | comp_expr • GT comp_expr
   94          | comp_expr • LT comp_expr
   95          | comp_expr • GEQ comp_expr
   96          | comp_expr • LEQ comp_expr
   97          | comp_expr • EQ comp_expr
   98          | comp_expr • NEQ comp_expr
   99          | comp_expr • KEYWORD_AND comp_expr
  100          | comp_expr • KEYWORD_OR comp_expr
  104          | comp_expr • POW comp_expr

    SEMICOLON    shift, and go to state 264
    KEYWORD_OR   shift, and go to state 265
    KEYWORD_AND  shift, and go to state 266
    EQ           shift, and go to state 267
    NEQ          shift, and go to state 268
    LT           shift, and go to state 269
    LEQ          shift, and go to state 270
    GT           shift, and go to state 271
    GEQ          shift, and go to state 272
    PLUS         shift, and go to state 273
    MINUS        shift, and go to state 274
    MULT         shift, and go to state 275
    DIV          shift, and go to state 276
    MOD          shift, and go to state 277
    POW          shift, and go to state 278


State 230

   87 comp_expr: operand •

    $default  reduce using rule 87 (comp_expr)


State 231

   52 comp_var_name: HASHTAG var_name •

    $default  reduce using rule 52 (comp_var_name)


State 232

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   72 comp_assign_stmt: comp_var_name ASSIGN • comp_expr SEMICOLON
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 225
    PLUS           shift, and go to state 226
    MINUS          shift, and go to state 227
    LPAREN         shift, and go to state 228

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 279
    operand    go to state 230
    func_call  go to state 51


State 233

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   73 comp_assign_stmt: comp_var_name PLUS_ASSIGN • comp_expr SEMICOLON
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 225
    PLUS           shift, and go to state 226
    MINUS          shift, and go to state 227
    LPAREN         shift, and go to state 228

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 280
    operand    go to state 230
    func_call  go to state 51


State 234

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   74 comp_assign_stmt: comp_var_name MINUS_ASSIGN • comp_expr SEMICOLON
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 225
    PLUS           shift, and go to state 226
    MINUS          shift, and go to state 227
    LPAREN         shift, and go to state 228

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 281
    operand    go to state 230
    func_call  go to state 51


State 235

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   67 comp_range_comprehension: comp_var_name COLON_ASSIGN • LBRACKET comp_expr KEYWORD_FOR comp_var_name COLON INTEGER RBRACKET COLON var_type SEMICOLON
   68 comp_arr_comprehension: comp_var_name COLON_ASSIGN • LBRACKET comp_expr KEYWORD_FOR comp_var_name COLON var_type KEYWORD_IN comp_var_name KEYWORD_OF INTEGER RBRACKET COLON var_type SEMICOLON
   78 comp_assign_stmt: comp_var_name COLON_ASSIGN • comp_expr SEMICOLON
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 225
    PLUS           shift, and go to state 226
    MINUS          shift, and go to state 227
    LBRACKET       shift, and go to state 282
    LPAREN         shift, and go to state 228

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 283
    operand    go to state 230
    func_call  go to state 51


State 236

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   75 comp_assign_stmt: comp_var_name MULT_ASSIGN • comp_expr SEMICOLON
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 225
    PLUS           shift, and go to state 226
    MINUS          shift, and go to state 227
    LPAREN         shift, and go to state 228

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 284
    operand    go to state 230
    func_call  go to state 51


State 237

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   76 comp_assign_stmt: comp_var_name DIV_ASSIGN • comp_expr SEMICOLON
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 225
    PLUS           shift, and go to state 226
    MINUS          shift, and go to state 227
    LPAREN         shift, and go to state 228

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 285
    operand    go to state 230
    func_call  go to state 51


State 238

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   77 comp_assign_stmt: comp_var_name MOD_ASSIGN • comp_expr SEMICOLON
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 225
    PLUS           shift, and go to state 226
    MINUS          shift, and go to state 227
    LPAREN         shift, and go to state 228

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 286
    operand    go to state 230
    func_call  go to state 51


State 239

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   83 comp_func_call: comp_var_name LPAREN • comp_expr_list RPAREN
   84 comp_expr_list: ε •  [RPAREN, COMMA]
   85               | • comp_expr
   86               | • comp_expr_list COMMA comp_expr
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 225
    PLUS           shift, and go to state 226
    MINUS          shift, and go to state 227
    LPAREN         shift, and go to state 228

    $default  reduce using rule 84 (comp_expr_list)

    var_name        go to state 47
    bool_dt         go to state 48
    comp_expr_list  go to state 287
    comp_expr       go to state 288
    operand         go to state 230
    func_call       go to state 51


State 240

   55 comp_stmts: comp_stmts comp_stmt •

    $default  reduce using rule 55 (comp_stmts)


State 241

   58 comp_stmt: comp_func_call SEMICOLON •

    $default  reduce using rule 58 (comp_stmt)


State 242

   14 func_header: KEYWORD_DEF IDENTIFIER LPAREN func_param_list RPAREN MINUS GT • var_type COLON
   28 var_type: • primitive_dt
   29         | • IDENTIFIER
   30 primitive_dt: • KEYWORD_SCALAR
   31             | • KEYWORD_INTEGER
   32             | • KEYWORD_STR
   33             | • KEYWORD_BOOL

    KEYWORD_SCALAR   shift, and go to state 59
    KEYWORD_STR      shift, and go to state 60
    KEYWORD_BOOL     shift, and go to state 61
    KEYWORD_INTEGER  shift, and go to state 62
    IDENTIFIER       shift, and go to state 63

    var_type      go to state 289
    primitive_dt  go to state 65


State 243

  165 if_stmt: KEYWORD_IF LPAREN expr RPAREN • COLON stmts KEYWORD_ENDIF SEMICOLON
  166        | KEYWORD_IF LPAREN expr RPAREN • COLON stmts KEYWORD_ELSE COLON stmts KEYWORD_ENDIF SEMICOLON

    COLON  shift, and go to state 290


State 244

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  150 for_stmt: KEYWORD_FOR var_name KEYWORD_IN LBRACKET • expr COLON expr COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON
  151         | KEYWORD_FOR var_name KEYWORD_IN LBRACKET • expr COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 291
    operand    go to state 50
    func_call  go to state 51


State 245

  152 while_stmt: KEYWORD_WHILE LPAREN expr RPAREN • COLON stmts KEYWORD_ENDWHILE SEMICOLON

    COLON  shift, and go to state 292


State 246

  153 assign_stmt: var_name ASSIGN expr SEMICOLON •

    $default  reduce using rule 153 (assign_stmt)


State 247

  154 assign_stmt: var_name PLUS_ASSIGN expr SEMICOLON •

    $default  reduce using rule 154 (assign_stmt)


State 248

  155 assign_stmt: var_name MINUS_ASSIGN expr SEMICOLON •

    $default  reduce using rule 155 (assign_stmt)


State 249

  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  124     | expr • POW expr
  148 range_comprehension: var_name COLON_ASSIGN LBRACKET expr • KEYWORD_FOR var_name COLON INTEGER RBRACKET COLON var_type SEMICOLON
  149 arr_comprehension: var_name COLON_ASSIGN LBRACKET expr • KEYWORD_FOR var_name COLON var_type KEYWORD_IN var_name KEYWORD_OF INTEGER RBRACKET COLON var_type SEMICOLON

    KEYWORD_FOR  shift, and go to state 293
    KEYWORD_OR   shift, and go to state 77
    KEYWORD_AND  shift, and go to state 78
    EQ           shift, and go to state 79
    NEQ          shift, and go to state 80
    LT           shift, and go to state 81
    LEQ          shift, and go to state 82
    GT           shift, and go to state 83
    GEQ          shift, and go to state 84
    PLUS         shift, and go to state 85
    MINUS        shift, and go to state 86
    MULT         shift, and go to state 87
    DIV          shift, and go to state 88
    MOD          shift, and go to state 89
    POW          shift, and go to state 90


State 250

  159 assign_stmt: var_name COLON_ASSIGN expr SEMICOLON •

    $default  reduce using rule 159 (assign_stmt)


State 251

  156 assign_stmt: var_name MULT_ASSIGN expr SEMICOLON •

    $default  reduce using rule 156 (assign_stmt)


State 252

  157 assign_stmt: var_name DIV_ASSIGN expr SEMICOLON •

    $default  reduce using rule 157 (assign_stmt)


State 253

  158 assign_stmt: var_name MOD_ASSIGN expr SEMICOLON •

    $default  reduce using rule 158 (assign_stmt)


State 254

   42 comp_func_header: KEYWORD_DEF IDENTIFIER LPAREN comp_func_param_list RPAREN MINUS • GT var_type COLON

    GT  shift, and go to state 294


State 255

   41 comp_func_header: KEYWORD_DEF IDENTIFIER LPAREN comp_func_param_list RPAREN COLON •

    $default  reduce using rule 41 (comp_func_header)


State 256

   45 comp_func_param_list: comp_func_param_list COMMA func_arg •

    $default  reduce using rule 45 (comp_func_param_list)


State 257

   81 comp_if_stmt: KEYWORD_IF LPAREN comp_expr • RPAREN COLON comp_stmts KEYWORD_ENDIF SEMICOLON
   82             | KEYWORD_IF LPAREN comp_expr • RPAREN COLON comp_stmts KEYWORD_ELSE COLON comp_stmts KEYWORD_ENDIF SEMICOLON
   88 comp_expr: comp_expr • PLUS comp_expr
   89          | comp_expr • MINUS comp_expr
   90          | comp_expr • MULT comp_expr
   91          | comp_expr • DIV comp_expr
   92          | comp_expr • MOD comp_expr
   93          | comp_expr • GT comp_expr
   94          | comp_expr • LT comp_expr
   95          | comp_expr • GEQ comp_expr
   96          | comp_expr • LEQ comp_expr
   97          | comp_expr • EQ comp_expr
   98          | comp_expr • NEQ comp_expr
   99          | comp_expr • KEYWORD_AND comp_expr
  100          | comp_expr • KEYWORD_OR comp_expr
  104          | comp_expr • POW comp_expr

    KEYWORD_OR   shift, and go to state 265
    KEYWORD_AND  shift, and go to state 266
    EQ           shift, and go to state 267
    NEQ          shift, and go to state 268
    LT           shift, and go to state 269
    LEQ          shift, and go to state 270
    GT           shift, and go to state 271
    GEQ          shift, and go to state 272
    PLUS         shift, and go to state 273
    MINUS        shift, and go to state 274
    MULT         shift, and go to state 275
    DIV          shift, and go to state 276
    MOD          shift, and go to state 277
    POW          shift, and go to state 278
    RPAREN       shift, and go to state 295


State 258

   69 comp_for_stmt: KEYWORD_FOR comp_var_name KEYWORD_IN • LBRACKET comp_expr COLON comp_expr COLON comp_expr RBRACKET COLON comp_stmts KEYWORD_ENDFOR SEMICOLON
   70              | KEYWORD_FOR comp_var_name KEYWORD_IN • LBRACKET expr COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON

    LBRACKET  shift, and go to state 296


State 259

   71 comp_while_stmt: KEYWORD_WHILE LPAREN comp_expr • RPAREN COLON comp_stmts KEYWORD_ENDWHILE SEMICOLON
   88 comp_expr: comp_expr • PLUS comp_expr
   89          | comp_expr • MINUS comp_expr
   90          | comp_expr • MULT comp_expr
   91          | comp_expr • DIV comp_expr
   92          | comp_expr • MOD comp_expr
   93          | comp_expr • GT comp_expr
   94          | comp_expr • LT comp_expr
   95          | comp_expr • GEQ comp_expr
   96          | comp_expr • LEQ comp_expr
   97          | comp_expr • EQ comp_expr
   98          | comp_expr • NEQ comp_expr
   99          | comp_expr • KEYWORD_AND comp_expr
  100          | comp_expr • KEYWORD_OR comp_expr
  104          | comp_expr • POW comp_expr

    KEYWORD_OR   shift, and go to state 265
    KEYWORD_AND  shift, and go to state 266
    EQ           shift, and go to state 267
    NEQ          shift, and go to state 268
    LT           shift, and go to state 269
    LEQ          shift, and go to state 270
    GT           shift, and go to state 271
    GEQ          shift, and go to state 272
    PLUS         shift, and go to state 273
    MINUS        shift, and go to state 274
    MULT         shift, and go to state 275
    DIV          shift, and go to state 276
    MOD          shift, and go to state 277
    POW          shift, and go to state 278
    RPAREN       shift, and go to state 297


State 260

   88 comp_expr: comp_expr • PLUS comp_expr
   89          | comp_expr • MINUS comp_expr
   90          | comp_expr • MULT comp_expr
   91          | comp_expr • DIV comp_expr
   92          | comp_expr • MOD comp_expr
   93          | comp_expr • GT comp_expr
   94          | comp_expr • LT comp_expr
   95          | comp_expr • GEQ comp_expr
   96          | comp_expr • LEQ comp_expr
   97          | comp_expr • EQ comp_expr
   98          | comp_expr • NEQ comp_expr
   99          | comp_expr • KEYWORD_AND comp_expr
  100          | comp_expr • KEYWORD_OR comp_expr
  101          | KEYWORD_NOT comp_expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, KEYWORD_AND, RBRACKET, RPAREN, COMMA, COLON]
  104          | comp_expr • POW comp_expr

    EQ     shift, and go to state 267
    NEQ    shift, and go to state 268
    LT     shift, and go to state 269
    LEQ    shift, and go to state 270
    GT     shift, and go to state 271
    GEQ    shift, and go to state 272
    PLUS   shift, and go to state 273
    MINUS  shift, and go to state 274
    MULT   shift, and go to state 275
    DIV    shift, and go to state 276
    MOD    shift, and go to state 277
    POW    shift, and go to state 278

    $default  reduce using rule 101 (comp_expr)

    Conflict between rule 101 and token KEYWORD_OR resolved as reduce (KEYWORD_OR < KEYWORD_NOT).
    Conflict between rule 101 and token KEYWORD_AND resolved as reduce (KEYWORD_AND < KEYWORD_NOT).
    Conflict between rule 101 and token EQ resolved as shift (KEYWORD_NOT < EQ).
    Conflict between rule 101 and token NEQ resolved as shift (KEYWORD_NOT < NEQ).
    Conflict between rule 101 and token LT resolved as shift (KEYWORD_NOT < LT).
    Conflict between rule 101 and token LEQ resolved as shift (KEYWORD_NOT < LEQ).
    Conflict between rule 101 and token GT resolved as shift (KEYWORD_NOT < GT).
    Conflict between rule 101 and token GEQ resolved as shift (KEYWORD_NOT < GEQ).
    Conflict between rule 101 and token PLUS resolved as shift (KEYWORD_NOT < PLUS).
    Conflict between rule 101 and token MINUS resolved as shift (KEYWORD_NOT < MINUS).
    Conflict between rule 101 and token MULT resolved as shift (KEYWORD_NOT < MULT).
    Conflict between rule 101 and token DIV resolved as shift (KEYWORD_NOT < DIV).
    Conflict between rule 101 and token MOD resolved as shift (KEYWORD_NOT < MOD).
    Conflict between rule 101 and token POW resolved as shift (KEYWORD_NOT < POW).


State 261

   88 comp_expr: comp_expr • PLUS comp_expr
   89          | comp_expr • MINUS comp_expr
   90          | comp_expr • MULT comp_expr
   91          | comp_expr • DIV comp_expr
   92          | comp_expr • MOD comp_expr
   93          | comp_expr • GT comp_expr
   94          | comp_expr • LT comp_expr
   95          | comp_expr • GEQ comp_expr
   96          | comp_expr • LEQ comp_expr
   97          | comp_expr • EQ comp_expr
   98          | comp_expr • NEQ comp_expr
   99          | comp_expr • KEYWORD_AND comp_expr
  100          | comp_expr • KEYWORD_OR comp_expr
  102          | PLUS comp_expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, KEYWORD_AND, EQ, NEQ, LT, LEQ, GT, GEQ, PLUS, RBRACKET, RPAREN, COMMA, COLON]
  104          | comp_expr • POW comp_expr

    MINUS  shift, and go to state 274
    MULT   shift, and go to state 275
    DIV    shift, and go to state 276
    MOD    shift, and go to state 277
    POW    shift, and go to state 278

    $default  reduce using rule 102 (comp_expr)

    Conflict between rule 102 and token KEYWORD_OR resolved as reduce (KEYWORD_OR < PLUS).
    Conflict between rule 102 and token KEYWORD_AND resolved as reduce (KEYWORD_AND < PLUS).
    Conflict between rule 102 and token EQ resolved as reduce (EQ < PLUS).
    Conflict between rule 102 and token NEQ resolved as reduce (NEQ < PLUS).
    Conflict between rule 102 and token LT resolved as reduce (LT < PLUS).
    Conflict between rule 102 and token LEQ resolved as reduce (LEQ < PLUS).
    Conflict between rule 102 and token GT resolved as reduce (GT < PLUS).
    Conflict between rule 102 and token GEQ resolved as reduce (GEQ < PLUS).
    Conflict between rule 102 and token PLUS resolved as reduce (%left PLUS).
    Conflict between rule 102 and token MINUS resolved as shift (PLUS < MINUS).
    Conflict between rule 102 and token MULT resolved as shift (PLUS < MULT).
    Conflict between rule 102 and token DIV resolved as shift (PLUS < DIV).
    Conflict between rule 102 and token MOD resolved as shift (PLUS < MOD).
    Conflict between rule 102 and token POW resolved as shift (PLUS < POW).


State 262

   88 comp_expr: comp_expr • PLUS comp_expr
   89          | comp_expr • MINUS comp_expr
   90          | comp_expr • MULT comp_expr
   91          | comp_expr • DIV comp_expr
   92          | comp_expr • MOD comp_expr
   93          | comp_expr • GT comp_expr
   94          | comp_expr • LT comp_expr
   95          | comp_expr • GEQ comp_expr
   96          | comp_expr • LEQ comp_expr
   97          | comp_expr • EQ comp_expr
   98          | comp_expr • NEQ comp_expr
   99          | comp_expr • KEYWORD_AND comp_expr
  100          | comp_expr • KEYWORD_OR comp_expr
  103          | MINUS comp_expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, KEYWORD_AND, EQ, NEQ, LT, LEQ, GT, GEQ, PLUS, MINUS, RBRACKET, RPAREN, COMMA, COLON]
  104          | comp_expr • POW comp_expr

    MULT  shift, and go to state 275
    DIV   shift, and go to state 276
    MOD   shift, and go to state 277
    POW   shift, and go to state 278

    $default  reduce using rule 103 (comp_expr)

    Conflict between rule 103 and token KEYWORD_OR resolved as reduce (KEYWORD_OR < MINUS).
    Conflict between rule 103 and token KEYWORD_AND resolved as reduce (KEYWORD_AND < MINUS).
    Conflict between rule 103 and token EQ resolved as reduce (EQ < MINUS).
    Conflict between rule 103 and token NEQ resolved as reduce (NEQ < MINUS).
    Conflict between rule 103 and token LT resolved as reduce (LT < MINUS).
    Conflict between rule 103 and token LEQ resolved as reduce (LEQ < MINUS).
    Conflict between rule 103 and token GT resolved as reduce (GT < MINUS).
    Conflict between rule 103 and token GEQ resolved as reduce (GEQ < MINUS).
    Conflict between rule 103 and token PLUS resolved as reduce (PLUS < MINUS).
    Conflict between rule 103 and token MINUS resolved as reduce (%left MINUS).
    Conflict between rule 103 and token MULT resolved as shift (MINUS < MULT).
    Conflict between rule 103 and token DIV resolved as shift (MINUS < DIV).
    Conflict between rule 103 and token MOD resolved as shift (MINUS < MOD).
    Conflict between rule 103 and token POW resolved as shift (MINUS < POW).


State 263

   88 comp_expr: comp_expr • PLUS comp_expr
   89          | comp_expr • MINUS comp_expr
   90          | comp_expr • MULT comp_expr
   91          | comp_expr • DIV comp_expr
   92          | comp_expr • MOD comp_expr
   93          | comp_expr • GT comp_expr
   94          | comp_expr • LT comp_expr
   95          | comp_expr • GEQ comp_expr
   96          | comp_expr • LEQ comp_expr
   97          | comp_expr • EQ comp_expr
   98          | comp_expr • NEQ comp_expr
   99          | comp_expr • KEYWORD_AND comp_expr
  100          | comp_expr • KEYWORD_OR comp_expr
  104          | comp_expr • POW comp_expr
  105          | LPAREN comp_expr • RPAREN

    KEYWORD_OR   shift, and go to state 265
    KEYWORD_AND  shift, and go to state 266
    EQ           shift, and go to state 267
    NEQ          shift, and go to state 268
    LT           shift, and go to state 269
    LEQ          shift, and go to state 270
    GT           shift, and go to state 271
    GEQ          shift, and go to state 272
    PLUS         shift, and go to state 273
    MINUS        shift, and go to state 274
    MULT         shift, and go to state 275
    DIV          shift, and go to state 276
    MOD          shift, and go to state 277
    POW          shift, and go to state 278
    RPAREN       shift, and go to state 298


State 264

   80 comp_return_stmt: KEYWORD_RETURN comp_expr SEMICOLON •

    $default  reduce using rule 80 (comp_return_stmt)


State 265

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  100          | comp_expr KEYWORD_OR • comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 225
    PLUS           shift, and go to state 226
    MINUS          shift, and go to state 227
    LPAREN         shift, and go to state 228

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 299
    operand    go to state 230
    func_call  go to state 51


State 266

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
   99          | comp_expr KEYWORD_AND • comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 225
    PLUS           shift, and go to state 226
    MINUS          shift, and go to state 227
    LPAREN         shift, and go to state 228

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 300
    operand    go to state 230
    func_call  go to state 51


State 267

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   97          | comp_expr EQ • comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 225
    PLUS           shift, and go to state 226
    MINUS          shift, and go to state 227
    LPAREN         shift, and go to state 228

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 301
    operand    go to state 230
    func_call  go to state 51


State 268

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   98          | comp_expr NEQ • comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 225
    PLUS           shift, and go to state 226
    MINUS          shift, and go to state 227
    LPAREN         shift, and go to state 228

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 302
    operand    go to state 230
    func_call  go to state 51


State 269

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   94          | comp_expr LT • comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 225
    PLUS           shift, and go to state 226
    MINUS          shift, and go to state 227
    LPAREN         shift, and go to state 228

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 303
    operand    go to state 230
    func_call  go to state 51


State 270

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   96          | comp_expr LEQ • comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 225
    PLUS           shift, and go to state 226
    MINUS          shift, and go to state 227
    LPAREN         shift, and go to state 228

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 304
    operand    go to state 230
    func_call  go to state 51


State 271

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   93          | comp_expr GT • comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 225
    PLUS           shift, and go to state 226
    MINUS          shift, and go to state 227
    LPAREN         shift, and go to state 228

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 305
    operand    go to state 230
    func_call  go to state 51


State 272

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   95          | comp_expr GEQ • comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 225
    PLUS           shift, and go to state 226
    MINUS          shift, and go to state 227
    LPAREN         shift, and go to state 228

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 306
    operand    go to state 230
    func_call  go to state 51


State 273

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   88          | comp_expr PLUS • comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 225
    PLUS           shift, and go to state 226
    MINUS          shift, and go to state 227
    LPAREN         shift, and go to state 228

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 307
    operand    go to state 230
    func_call  go to state 51


State 274

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   89          | comp_expr MINUS • comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 225
    PLUS           shift, and go to state 226
    MINUS          shift, and go to state 227
    LPAREN         shift, and go to state 228

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 308
    operand    go to state 230
    func_call  go to state 51


State 275

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   90          | comp_expr MULT • comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 225
    PLUS           shift, and go to state 226
    MINUS          shift, and go to state 227
    LPAREN         shift, and go to state 228

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 309
    operand    go to state 230
    func_call  go to state 51


State 276

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   91          | comp_expr DIV • comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 225
    PLUS           shift, and go to state 226
    MINUS          shift, and go to state 227
    LPAREN         shift, and go to state 228

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 310
    operand    go to state 230
    func_call  go to state 51


State 277

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   92          | comp_expr MOD • comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 225
    PLUS           shift, and go to state 226
    MINUS          shift, and go to state 227
    LPAREN         shift, and go to state 228

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 311
    operand    go to state 230
    func_call  go to state 51


State 278

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  104          | comp_expr POW • comp_expr
  105          | • LPAREN comp_expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 225
    PLUS           shift, and go to state 226
    MINUS          shift, and go to state 227
    LPAREN         shift, and go to state 228

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 312
    operand    go to state 230
    func_call  go to state 51


State 279

   72 comp_assign_stmt: comp_var_name ASSIGN comp_expr • SEMICOLON
   88 comp_expr: comp_expr • PLUS comp_expr
   89          | comp_expr • MINUS comp_expr
   90          | comp_expr • MULT comp_expr
   91          | comp_expr • DIV comp_expr
   92          | comp_expr • MOD comp_expr
   93          | comp_expr • GT comp_expr
   94          | comp_expr • LT comp_expr
   95          | comp_expr • GEQ comp_expr
   96          | comp_expr • LEQ comp_expr
   97          | comp_expr • EQ comp_expr
   98          | comp_expr • NEQ comp_expr
   99          | comp_expr • KEYWORD_AND comp_expr
  100          | comp_expr • KEYWORD_OR comp_expr
  104          | comp_expr • POW comp_expr

    SEMICOLON    shift, and go to state 313
    KEYWORD_OR   shift, and go to state 265
    KEYWORD_AND  shift, and go to state 266
    EQ           shift, and go to state 267
    NEQ          shift, and go to state 268
    LT           shift, and go to state 269
    LEQ          shift, and go to state 270
    GT           shift, and go to state 271
    GEQ          shift, and go to state 272
    PLUS         shift, and go to state 273
    MINUS        shift, and go to state 274
    MULT         shift, and go to state 275
    DIV          shift, and go to state 276
    MOD          shift, and go to state 277
    POW          shift, and go to state 278


State 280

   73 comp_assign_stmt: comp_var_name PLUS_ASSIGN comp_expr • SEMICOLON
   88 comp_expr: comp_expr • PLUS comp_expr
   89          | comp_expr • MINUS comp_expr
   90          | comp_expr • MULT comp_expr
   91          | comp_expr • DIV comp_expr
   92          | comp_expr • MOD comp_expr
   93          | comp_expr • GT comp_expr
   94          | comp_expr • LT comp_expr
   95          | comp_expr • GEQ comp_expr
   96          | comp_expr • LEQ comp_expr
   97          | comp_expr • EQ comp_expr
   98          | comp_expr • NEQ comp_expr
   99          | comp_expr • KEYWORD_AND comp_expr
  100          | comp_expr • KEYWORD_OR comp_expr
  104          | comp_expr • POW comp_expr

    SEMICOLON    shift, and go to state 314
    KEYWORD_OR   shift, and go to state 265
    KEYWORD_AND  shift, and go to state 266
    EQ           shift, and go to state 267
    NEQ          shift, and go to state 268
    LT           shift, and go to state 269
    LEQ          shift, and go to state 270
    GT           shift, and go to state 271
    GEQ          shift, and go to state 272
    PLUS         shift, and go to state 273
    MINUS        shift, and go to state 274
    MULT         shift, and go to state 275
    DIV          shift, and go to state 276
    MOD          shift, and go to state 277
    POW          shift, and go to state 278


State 281

   74 comp_assign_stmt: comp_var_name MINUS_ASSIGN comp_expr • SEMICOLON
   88 comp_expr: comp_expr • PLUS comp_expr
   89          | comp_expr • MINUS comp_expr
   90          | comp_expr • MULT comp_expr
   91          | comp_expr • DIV comp_expr
   92          | comp_expr • MOD comp_expr
   93          | comp_expr • GT comp_expr
   94          | comp_expr • LT comp_expr
   95          | comp_expr • GEQ comp_expr
   96          | comp_expr • LEQ comp_expr
   97          | comp_expr • EQ comp_expr
   98          | comp_expr • NEQ comp_expr
   99          | comp_expr • KEYWORD_AND comp_expr
  100          | comp_expr • KEYWORD_OR comp_expr
  104          | comp_expr • POW comp_expr

    SEMICOLON    shift, and go to state 315
    KEYWORD_OR   shift, and go to state 265
    KEYWORD_AND  shift, and go to state 266
    EQ           shift, and go to state 267
    NEQ          shift, and go to state 268
    LT           shift, and go to state 269
    LEQ          shift, and go to state 270
    GT           shift, and go to state 271
    GEQ          shift, and go to state 272
    PLUS         shift, and go to state 273
    MINUS        shift, and go to state 274
    MULT         shift, and go to state 275
    DIV          shift, and go to state 276
    MOD          shift, and go to state 277
    POW          shift, and go to state 278


State 282

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   67 comp_range_comprehension: comp_var_name COLON_ASSIGN LBRACKET • comp_expr KEYWORD_FOR comp_var_name COLON INTEGER RBRACKET COLON var_type SEMICOLON
   68 comp_arr_comprehension: comp_var_name COLON_ASSIGN LBRACKET • comp_expr KEYWORD_FOR comp_var_name COLON var_type KEYWORD_IN comp_var_name KEYWORD_OF INTEGER RBRACKET COLON var_type SEMICOLON
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 225
    PLUS           shift, and go to state 226
    MINUS          shift, and go to state 227
    LPAREN         shift, and go to state 228

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 316
    operand    go to state 230
    func_call  go to state 51


State 283

   78 comp_assign_stmt: comp_var_name COLON_ASSIGN comp_expr • SEMICOLON
   88 comp_expr: comp_expr • PLUS comp_expr
   89          | comp_expr • MINUS comp_expr
   90          | comp_expr • MULT comp_expr
   91          | comp_expr • DIV comp_expr
   92          | comp_expr • MOD comp_expr
   93          | comp_expr • GT comp_expr
   94          | comp_expr • LT comp_expr
   95          | comp_expr • GEQ comp_expr
   96          | comp_expr • LEQ comp_expr
   97          | comp_expr • EQ comp_expr
   98          | comp_expr • NEQ comp_expr
   99          | comp_expr • KEYWORD_AND comp_expr
  100          | comp_expr • KEYWORD_OR comp_expr
  104          | comp_expr • POW comp_expr

    SEMICOLON    shift, and go to state 317
    KEYWORD_OR   shift, and go to state 265
    KEYWORD_AND  shift, and go to state 266
    EQ           shift, and go to state 267
    NEQ          shift, and go to state 268
    LT           shift, and go to state 269
    LEQ          shift, and go to state 270
    GT           shift, and go to state 271
    GEQ          shift, and go to state 272
    PLUS         shift, and go to state 273
    MINUS        shift, and go to state 274
    MULT         shift, and go to state 275
    DIV          shift, and go to state 276
    MOD          shift, and go to state 277
    POW          shift, and go to state 278


State 284

   75 comp_assign_stmt: comp_var_name MULT_ASSIGN comp_expr • SEMICOLON
   88 comp_expr: comp_expr • PLUS comp_expr
   89          | comp_expr • MINUS comp_expr
   90          | comp_expr • MULT comp_expr
   91          | comp_expr • DIV comp_expr
   92          | comp_expr • MOD comp_expr
   93          | comp_expr • GT comp_expr
   94          | comp_expr • LT comp_expr
   95          | comp_expr • GEQ comp_expr
   96          | comp_expr • LEQ comp_expr
   97          | comp_expr • EQ comp_expr
   98          | comp_expr • NEQ comp_expr
   99          | comp_expr • KEYWORD_AND comp_expr
  100          | comp_expr • KEYWORD_OR comp_expr
  104          | comp_expr • POW comp_expr

    SEMICOLON    shift, and go to state 318
    KEYWORD_OR   shift, and go to state 265
    KEYWORD_AND  shift, and go to state 266
    EQ           shift, and go to state 267
    NEQ          shift, and go to state 268
    LT           shift, and go to state 269
    LEQ          shift, and go to state 270
    GT           shift, and go to state 271
    GEQ          shift, and go to state 272
    PLUS         shift, and go to state 273
    MINUS        shift, and go to state 274
    MULT         shift, and go to state 275
    DIV          shift, and go to state 276
    MOD          shift, and go to state 277
    POW          shift, and go to state 278


State 285

   76 comp_assign_stmt: comp_var_name DIV_ASSIGN comp_expr • SEMICOLON
   88 comp_expr: comp_expr • PLUS comp_expr
   89          | comp_expr • MINUS comp_expr
   90          | comp_expr • MULT comp_expr
   91          | comp_expr • DIV comp_expr
   92          | comp_expr • MOD comp_expr
   93          | comp_expr • GT comp_expr
   94          | comp_expr • LT comp_expr
   95          | comp_expr • GEQ comp_expr
   96          | comp_expr • LEQ comp_expr
   97          | comp_expr • EQ comp_expr
   98          | comp_expr • NEQ comp_expr
   99          | comp_expr • KEYWORD_AND comp_expr
  100          | comp_expr • KEYWORD_OR comp_expr
  104          | comp_expr • POW comp_expr

    SEMICOLON    shift, and go to state 319
    KEYWORD_OR   shift, and go to state 265
    KEYWORD_AND  shift, and go to state 266
    EQ           shift, and go to state 267
    NEQ          shift, and go to state 268
    LT           shift, and go to state 269
    LEQ          shift, and go to state 270
    GT           shift, and go to state 271
    GEQ          shift, and go to state 272
    PLUS         shift, and go to state 273
    MINUS        shift, and go to state 274
    MULT         shift, and go to state 275
    DIV          shift, and go to state 276
    MOD          shift, and go to state 277
    POW          shift, and go to state 278


State 286

   77 comp_assign_stmt: comp_var_name MOD_ASSIGN comp_expr • SEMICOLON
   88 comp_expr: comp_expr • PLUS comp_expr
   89          | comp_expr • MINUS comp_expr
   90          | comp_expr • MULT comp_expr
   91          | comp_expr • DIV comp_expr
   92          | comp_expr • MOD comp_expr
   93          | comp_expr • GT comp_expr
   94          | comp_expr • LT comp_expr
   95          | comp_expr • GEQ comp_expr
   96          | comp_expr • LEQ comp_expr
   97          | comp_expr • EQ comp_expr
   98          | comp_expr • NEQ comp_expr
   99          | comp_expr • KEYWORD_AND comp_expr
  100          | comp_expr • KEYWORD_OR comp_expr
  104          | comp_expr • POW comp_expr

    SEMICOLON    shift, and go to state 320
    KEYWORD_OR   shift, and go to state 265
    KEYWORD_AND  shift, and go to state 266
    EQ           shift, and go to state 267
    NEQ          shift, and go to state 268
    LT           shift, and go to state 269
    LEQ          shift, and go to state 270
    GT           shift, and go to state 271
    GEQ          shift, and go to state 272
    PLUS         shift, and go to state 273
    MINUS        shift, and go to state 274
    MULT         shift, and go to state 275
    DIV          shift, and go to state 276
    MOD          shift, and go to state 277
    POW          shift, and go to state 278


State 287

   83 comp_func_call: comp_var_name LPAREN comp_expr_list • RPAREN
   86 comp_expr_list: comp_expr_list • COMMA comp_expr

    RPAREN  shift, and go to state 321
    COMMA   shift, and go to state 322


State 288

   85 comp_expr_list: comp_expr •  [RPAREN, COMMA]
   88 comp_expr: comp_expr • PLUS comp_expr
   89          | comp_expr • MINUS comp_expr
   90          | comp_expr • MULT comp_expr
   91          | comp_expr • DIV comp_expr
   92          | comp_expr • MOD comp_expr
   93          | comp_expr • GT comp_expr
   94          | comp_expr • LT comp_expr
   95          | comp_expr • GEQ comp_expr
   96          | comp_expr • LEQ comp_expr
   97          | comp_expr • EQ comp_expr
   98          | comp_expr • NEQ comp_expr
   99          | comp_expr • KEYWORD_AND comp_expr
  100          | comp_expr • KEYWORD_OR comp_expr
  104          | comp_expr • POW comp_expr

    KEYWORD_OR   shift, and go to state 265
    KEYWORD_AND  shift, and go to state 266
    EQ           shift, and go to state 267
    NEQ          shift, and go to state 268
    LT           shift, and go to state 269
    LEQ          shift, and go to state 270
    GT           shift, and go to state 271
    GEQ          shift, and go to state 272
    PLUS         shift, and go to state 273
    MINUS        shift, and go to state 274
    MULT         shift, and go to state 275
    DIV          shift, and go to state 276
    MOD          shift, and go to state 277
    POW          shift, and go to state 278

    $default  reduce using rule 85 (comp_expr_list)


State 289

   14 func_header: KEYWORD_DEF IDENTIFIER LPAREN func_param_list RPAREN MINUS GT var_type • COLON

    COLON  shift, and go to state 323


State 290

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
  135 stmts: • stmt
  136      | • stmts stmt
  137 stmt: • empty_stmt
  138     | • if_stmt
  139     | • func_call SEMICOLON
  140     | • return_stmt
  141     | • break_stmt
  142     | • continue_stmt
  143     | • while_stmt
  144     | • for_stmt
  145     | • assign_stmt
  146     | • range_comprehension
  147     | • arr_comprehension
  148 range_comprehension: • var_name COLON_ASSIGN LBRACKET expr KEYWORD_FOR var_name COLON INTEGER RBRACKET COLON var_type SEMICOLON
  149 arr_comprehension: • var_name COLON_ASSIGN LBRACKET expr KEYWORD_FOR var_name COLON var_type KEYWORD_IN var_name KEYWORD_OF INTEGER RBRACKET COLON var_type SEMICOLON
  150 for_stmt: • KEYWORD_FOR var_name KEYWORD_IN LBRACKET expr COLON expr COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON
  151         | • KEYWORD_FOR var_name KEYWORD_IN LBRACKET expr COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON
  152 while_stmt: • KEYWORD_WHILE LPAREN expr RPAREN COLON stmts KEYWORD_ENDWHILE SEMICOLON
  153 assign_stmt: • var_name ASSIGN expr SEMICOLON
  154            | • var_name PLUS_ASSIGN expr SEMICOLON
  155            | • var_name MINUS_ASSIGN expr SEMICOLON
  156            | • var_name MULT_ASSIGN expr SEMICOLON
  157            | • var_name DIV_ASSIGN expr SEMICOLON
  158            | • var_name MOD_ASSIGN expr SEMICOLON
  159            | • var_name COLON_ASSIGN expr SEMICOLON
  160 return_stmt: • KEYWORD_RETURN SEMICOLON
  161            | • KEYWORD_RETURN expr SEMICOLON
  162 break_stmt: • KEYWORD_BREAK SEMICOLON
  163 continue_stmt: • KEYWORD_CONTINUE SEMICOLON
  164 empty_stmt: • SEMICOLON
  165 if_stmt: • KEYWORD_IF LPAREN expr RPAREN COLON stmts KEYWORD_ENDIF SEMICOLON
  165        | KEYWORD_IF LPAREN expr RPAREN COLON • stmts KEYWORD_ENDIF SEMICOLON
  166        | • KEYWORD_IF LPAREN expr RPAREN COLON stmts KEYWORD_ELSE COLON stmts KEYWORD_ENDIF SEMICOLON
  166        | KEYWORD_IF LPAREN expr RPAREN COLON • stmts KEYWORD_ELSE COLON stmts KEYWORD_ENDIF SEMICOLON
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_IF        shift, and go to state 128
    KEYWORD_FOR       shift, and go to state 129
    KEYWORD_WHILE     shift, and go to state 130
    KEYWORD_BREAK     shift, and go to state 131
    KEYWORD_CONTINUE  shift, and go to state 132
    KEYWORD_RETURN    shift, and go to state 133
    IDENTIFIER        shift, and go to state 39
    SEMICOLON         shift, and go to state 134

    var_name             go to state 175
    stmts                go to state 324
    stmt                 go to state 137
    range_comprehension  go to state 138
    arr_comprehension    go to state 139
    for_stmt             go to state 140
    while_stmt           go to state 141
    assign_stmt          go to state 142
    return_stmt          go to state 143
    break_stmt           go to state 144
    continue_stmt        go to state 145
    empty_stmt           go to state 146
    if_stmt              go to state 147
    func_call            go to state 148


State 291

  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  124     | expr • POW expr
  150 for_stmt: KEYWORD_FOR var_name KEYWORD_IN LBRACKET expr • COLON expr COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON
  151         | KEYWORD_FOR var_name KEYWORD_IN LBRACKET expr • COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON

    KEYWORD_OR   shift, and go to state 77
    KEYWORD_AND  shift, and go to state 78
    EQ           shift, and go to state 79
    NEQ          shift, and go to state 80
    LT           shift, and go to state 81
    LEQ          shift, and go to state 82
    GT           shift, and go to state 83
    GEQ          shift, and go to state 84
    PLUS         shift, and go to state 85
    MINUS        shift, and go to state 86
    MULT         shift, and go to state 87
    DIV          shift, and go to state 88
    MOD          shift, and go to state 89
    POW          shift, and go to state 90
    COLON        shift, and go to state 325


State 292

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
  135 stmts: • stmt
  136      | • stmts stmt
  137 stmt: • empty_stmt
  138     | • if_stmt
  139     | • func_call SEMICOLON
  140     | • return_stmt
  141     | • break_stmt
  142     | • continue_stmt
  143     | • while_stmt
  144     | • for_stmt
  145     | • assign_stmt
  146     | • range_comprehension
  147     | • arr_comprehension
  148 range_comprehension: • var_name COLON_ASSIGN LBRACKET expr KEYWORD_FOR var_name COLON INTEGER RBRACKET COLON var_type SEMICOLON
  149 arr_comprehension: • var_name COLON_ASSIGN LBRACKET expr KEYWORD_FOR var_name COLON var_type KEYWORD_IN var_name KEYWORD_OF INTEGER RBRACKET COLON var_type SEMICOLON
  150 for_stmt: • KEYWORD_FOR var_name KEYWORD_IN LBRACKET expr COLON expr COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON
  151         | • KEYWORD_FOR var_name KEYWORD_IN LBRACKET expr COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON
  152 while_stmt: • KEYWORD_WHILE LPAREN expr RPAREN COLON stmts KEYWORD_ENDWHILE SEMICOLON
  152           | KEYWORD_WHILE LPAREN expr RPAREN COLON • stmts KEYWORD_ENDWHILE SEMICOLON
  153 assign_stmt: • var_name ASSIGN expr SEMICOLON
  154            | • var_name PLUS_ASSIGN expr SEMICOLON
  155            | • var_name MINUS_ASSIGN expr SEMICOLON
  156            | • var_name MULT_ASSIGN expr SEMICOLON
  157            | • var_name DIV_ASSIGN expr SEMICOLON
  158            | • var_name MOD_ASSIGN expr SEMICOLON
  159            | • var_name COLON_ASSIGN expr SEMICOLON
  160 return_stmt: • KEYWORD_RETURN SEMICOLON
  161            | • KEYWORD_RETURN expr SEMICOLON
  162 break_stmt: • KEYWORD_BREAK SEMICOLON
  163 continue_stmt: • KEYWORD_CONTINUE SEMICOLON
  164 empty_stmt: • SEMICOLON
  165 if_stmt: • KEYWORD_IF LPAREN expr RPAREN COLON stmts KEYWORD_ENDIF SEMICOLON
  166        | • KEYWORD_IF LPAREN expr RPAREN COLON stmts KEYWORD_ELSE COLON stmts KEYWORD_ENDIF SEMICOLON
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_IF        shift, and go to state 128
    KEYWORD_FOR       shift, and go to state 129
    KEYWORD_WHILE     shift, and go to state 130
    KEYWORD_BREAK     shift, and go to state 131
    KEYWORD_CONTINUE  shift, and go to state 132
    KEYWORD_RETURN    shift, and go to state 133
    IDENTIFIER        shift, and go to state 39
    SEMICOLON         shift, and go to state 134

    var_name             go to state 175
    stmts                go to state 326
    stmt                 go to state 137
    range_comprehension  go to state 138
    arr_comprehension    go to state 139
    for_stmt             go to state 140
    while_stmt           go to state 141
    assign_stmt          go to state 142
    return_stmt          go to state 143
    break_stmt           go to state 144
    continue_stmt        go to state 145
    empty_stmt           go to state 146
    if_stmt              go to state 147
    func_call            go to state 148


State 293

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
  148 range_comprehension: var_name COLON_ASSIGN LBRACKET expr KEYWORD_FOR • var_name COLON INTEGER RBRACKET COLON var_type SEMICOLON
  149 arr_comprehension: var_name COLON_ASSIGN LBRACKET expr KEYWORD_FOR • var_name COLON var_type KEYWORD_IN var_name KEYWORD_OF INTEGER RBRACKET COLON var_type SEMICOLON

    IDENTIFIER  shift, and go to state 13

    var_name  go to state 327


State 294

   28 var_type: • primitive_dt
   29         | • IDENTIFIER
   30 primitive_dt: • KEYWORD_SCALAR
   31             | • KEYWORD_INTEGER
   32             | • KEYWORD_STR
   33             | • KEYWORD_BOOL
   42 comp_func_header: KEYWORD_DEF IDENTIFIER LPAREN comp_func_param_list RPAREN MINUS GT • var_type COLON

    KEYWORD_SCALAR   shift, and go to state 59
    KEYWORD_STR      shift, and go to state 60
    KEYWORD_BOOL     shift, and go to state 61
    KEYWORD_INTEGER  shift, and go to state 62
    IDENTIFIER       shift, and go to state 63

    var_type      go to state 328
    primitive_dt  go to state 65


State 295

   81 comp_if_stmt: KEYWORD_IF LPAREN comp_expr RPAREN • COLON comp_stmts KEYWORD_ENDIF SEMICOLON
   82             | KEYWORD_IF LPAREN comp_expr RPAREN • COLON comp_stmts KEYWORD_ELSE COLON comp_stmts KEYWORD_ENDIF SEMICOLON

    COLON  shift, and go to state 329


State 296

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   69 comp_for_stmt: KEYWORD_FOR comp_var_name KEYWORD_IN LBRACKET • comp_expr COLON comp_expr COLON comp_expr RBRACKET COLON comp_stmts KEYWORD_ENDFOR SEMICOLON
   70              | KEYWORD_FOR comp_var_name KEYWORD_IN LBRACKET • expr COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 330
    PLUS           shift, and go to state 331
    MINUS          shift, and go to state 332
    LPAREN         shift, and go to state 333

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 334
    expr       go to state 335
    operand    go to state 336
    func_call  go to state 51


State 297

   71 comp_while_stmt: KEYWORD_WHILE LPAREN comp_expr RPAREN • COLON comp_stmts KEYWORD_ENDWHILE SEMICOLON

    COLON  shift, and go to state 337


State 298

  105 comp_expr: LPAREN comp_expr RPAREN •

    $default  reduce using rule 105 (comp_expr)


State 299

   88 comp_expr: comp_expr • PLUS comp_expr
   89          | comp_expr • MINUS comp_expr
   90          | comp_expr • MULT comp_expr
   91          | comp_expr • DIV comp_expr
   92          | comp_expr • MOD comp_expr
   93          | comp_expr • GT comp_expr
   94          | comp_expr • LT comp_expr
   95          | comp_expr • GEQ comp_expr
   96          | comp_expr • LEQ comp_expr
   97          | comp_expr • EQ comp_expr
   98          | comp_expr • NEQ comp_expr
   99          | comp_expr • KEYWORD_AND comp_expr
  100          | comp_expr • KEYWORD_OR comp_expr
  100          | comp_expr KEYWORD_OR comp_expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, RBRACKET, RPAREN, COMMA, COLON]
  104          | comp_expr • POW comp_expr

    KEYWORD_AND  shift, and go to state 266
    EQ           shift, and go to state 267
    NEQ          shift, and go to state 268
    LT           shift, and go to state 269
    LEQ          shift, and go to state 270
    GT           shift, and go to state 271
    GEQ          shift, and go to state 272
    PLUS         shift, and go to state 273
    MINUS        shift, and go to state 274
    MULT         shift, and go to state 275
    DIV          shift, and go to state 276
    MOD          shift, and go to state 277
    POW          shift, and go to state 278

    $default  reduce using rule 100 (comp_expr)

    Conflict between rule 100 and token KEYWORD_OR resolved as reduce (%left KEYWORD_OR).
    Conflict between rule 100 and token KEYWORD_AND resolved as shift (KEYWORD_OR < KEYWORD_AND).
    Conflict between rule 100 and token EQ resolved as shift (KEYWORD_OR < EQ).
    Conflict between rule 100 and token NEQ resolved as shift (KEYWORD_OR < NEQ).
    Conflict between rule 100 and token LT resolved as shift (KEYWORD_OR < LT).
    Conflict between rule 100 and token LEQ resolved as shift (KEYWORD_OR < LEQ).
    Conflict between rule 100 and token GT resolved as shift (KEYWORD_OR < GT).
    Conflict between rule 100 and token GEQ resolved as shift (KEYWORD_OR < GEQ).
    Conflict between rule 100 and token PLUS resolved as shift (KEYWORD_OR < PLUS).
    Conflict between rule 100 and token MINUS resolved as shift (KEYWORD_OR < MINUS).
    Conflict between rule 100 and token MULT resolved as shift (KEYWORD_OR < MULT).
    Conflict between rule 100 and token DIV resolved as shift (KEYWORD_OR < DIV).
    Conflict between rule 100 and token MOD resolved as shift (KEYWORD_OR < MOD).
    Conflict between rule 100 and token POW resolved as shift (KEYWORD_OR < POW).


State 300

   88 comp_expr: comp_expr • PLUS comp_expr
   89          | comp_expr • MINUS comp_expr
   90          | comp_expr • MULT comp_expr
   91          | comp_expr • DIV comp_expr
   92          | comp_expr • MOD comp_expr
   93          | comp_expr • GT comp_expr
   94          | comp_expr • LT comp_expr
   95          | comp_expr • GEQ comp_expr
   96          | comp_expr • LEQ comp_expr
   97          | comp_expr • EQ comp_expr
   98          | comp_expr • NEQ comp_expr
   99          | comp_expr • KEYWORD_AND comp_expr
   99          | comp_expr KEYWORD_AND comp_expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, KEYWORD_AND, RBRACKET, RPAREN, COMMA, COLON]
  100          | comp_expr • KEYWORD_OR comp_expr
  104          | comp_expr • POW comp_expr

    EQ     shift, and go to state 267
    NEQ    shift, and go to state 268
    LT     shift, and go to state 269
    LEQ    shift, and go to state 270
    GT     shift, and go to state 271
    GEQ    shift, and go to state 272
    PLUS   shift, and go to state 273
    MINUS  shift, and go to state 274
    MULT   shift, and go to state 275
    DIV    shift, and go to state 276
    MOD    shift, and go to state 277
    POW    shift, and go to state 278

    $default  reduce using rule 99 (comp_expr)

    Conflict between rule 99 and token KEYWORD_OR resolved as reduce (KEYWORD_OR < KEYWORD_AND).
    Conflict between rule 99 and token KEYWORD_AND resolved as reduce (%left KEYWORD_AND).
    Conflict between rule 99 and token EQ resolved as shift (KEYWORD_AND < EQ).
    Conflict between rule 99 and token NEQ resolved as shift (KEYWORD_AND < NEQ).
    Conflict between rule 99 and token LT resolved as shift (KEYWORD_AND < LT).
    Conflict between rule 99 and token LEQ resolved as shift (KEYWORD_AND < LEQ).
    Conflict between rule 99 and token GT resolved as shift (KEYWORD_AND < GT).
    Conflict between rule 99 and token GEQ resolved as shift (KEYWORD_AND < GEQ).
    Conflict between rule 99 and token PLUS resolved as shift (KEYWORD_AND < PLUS).
    Conflict between rule 99 and token MINUS resolved as shift (KEYWORD_AND < MINUS).
    Conflict between rule 99 and token MULT resolved as shift (KEYWORD_AND < MULT).
    Conflict between rule 99 and token DIV resolved as shift (KEYWORD_AND < DIV).
    Conflict between rule 99 and token MOD resolved as shift (KEYWORD_AND < MOD).
    Conflict between rule 99 and token POW resolved as shift (KEYWORD_AND < POW).


State 301

   88 comp_expr: comp_expr • PLUS comp_expr
   89          | comp_expr • MINUS comp_expr
   90          | comp_expr • MULT comp_expr
   91          | comp_expr • DIV comp_expr
   92          | comp_expr • MOD comp_expr
   93          | comp_expr • GT comp_expr
   94          | comp_expr • LT comp_expr
   95          | comp_expr • GEQ comp_expr
   96          | comp_expr • LEQ comp_expr
   97          | comp_expr • EQ comp_expr
   97          | comp_expr EQ comp_expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, KEYWORD_AND, EQ, RBRACKET, RPAREN, COMMA, COLON]
   98          | comp_expr • NEQ comp_expr
   99          | comp_expr • KEYWORD_AND comp_expr
  100          | comp_expr • KEYWORD_OR comp_expr
  104          | comp_expr • POW comp_expr

    NEQ    shift, and go to state 268
    LT     shift, and go to state 269
    LEQ    shift, and go to state 270
    GT     shift, and go to state 271
    GEQ    shift, and go to state 272
    PLUS   shift, and go to state 273
    MINUS  shift, and go to state 274
    MULT   shift, and go to state 275
    DIV    shift, and go to state 276
    MOD    shift, and go to state 277
    POW    shift, and go to state 278

    $default  reduce using rule 97 (comp_expr)

    Conflict between rule 97 and token KEYWORD_OR resolved as reduce (KEYWORD_OR < EQ).
    Conflict between rule 97 and token KEYWORD_AND resolved as reduce (KEYWORD_AND < EQ).
    Conflict between rule 97 and token EQ resolved as reduce (%left EQ).
    Conflict between rule 97 and token NEQ resolved as shift (EQ < NEQ).
    Conflict between rule 97 and token LT resolved as shift (EQ < LT).
    Conflict between rule 97 and token LEQ resolved as shift (EQ < LEQ).
    Conflict between rule 97 and token GT resolved as shift (EQ < GT).
    Conflict between rule 97 and token GEQ resolved as shift (EQ < GEQ).
    Conflict between rule 97 and token PLUS resolved as shift (EQ < PLUS).
    Conflict between rule 97 and token MINUS resolved as shift (EQ < MINUS).
    Conflict between rule 97 and token MULT resolved as shift (EQ < MULT).
    Conflict between rule 97 and token DIV resolved as shift (EQ < DIV).
    Conflict between rule 97 and token MOD resolved as shift (EQ < MOD).
    Conflict between rule 97 and token POW resolved as shift (EQ < POW).


State 302

   88 comp_expr: comp_expr • PLUS comp_expr
   89          | comp_expr • MINUS comp_expr
   90          | comp_expr • MULT comp_expr
   91          | comp_expr • DIV comp_expr
   92          | comp_expr • MOD comp_expr
   93          | comp_expr • GT comp_expr
   94          | comp_expr • LT comp_expr
   95          | comp_expr • GEQ comp_expr
   96          | comp_expr • LEQ comp_expr
   97          | comp_expr • EQ comp_expr
   98          | comp_expr • NEQ comp_expr
   98          | comp_expr NEQ comp_expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, KEYWORD_AND, EQ, NEQ, RBRACKET, RPAREN, COMMA, COLON]
   99          | comp_expr • KEYWORD_AND comp_expr
  100          | comp_expr • KEYWORD_OR comp_expr
  104          | comp_expr • POW comp_expr

    LT     shift, and go to state 269
    LEQ    shift, and go to state 270
    GT     shift, and go to state 271
    GEQ    shift, and go to state 272
    PLUS   shift, and go to state 273
    MINUS  shift, and go to state 274
    MULT   shift, and go to state 275
    DIV    shift, and go to state 276
    MOD    shift, and go to state 277
    POW    shift, and go to state 278

    $default  reduce using rule 98 (comp_expr)

    Conflict between rule 98 and token KEYWORD_OR resolved as reduce (KEYWORD_OR < NEQ).
    Conflict between rule 98 and token KEYWORD_AND resolved as reduce (KEYWORD_AND < NEQ).
    Conflict between rule 98 and token EQ resolved as reduce (EQ < NEQ).
    Conflict between rule 98 and token NEQ resolved as reduce (%left NEQ).
    Conflict between rule 98 and token LT resolved as shift (NEQ < LT).
    Conflict between rule 98 and token LEQ resolved as shift (NEQ < LEQ).
    Conflict between rule 98 and token GT resolved as shift (NEQ < GT).
    Conflict between rule 98 and token GEQ resolved as shift (NEQ < GEQ).
    Conflict between rule 98 and token PLUS resolved as shift (NEQ < PLUS).
    Conflict between rule 98 and token MINUS resolved as shift (NEQ < MINUS).
    Conflict between rule 98 and token MULT resolved as shift (NEQ < MULT).
    Conflict between rule 98 and token DIV resolved as shift (NEQ < DIV).
    Conflict between rule 98 and token MOD resolved as shift (NEQ < MOD).
    Conflict between rule 98 and token POW resolved as shift (NEQ < POW).


State 303

   88 comp_expr: comp_expr • PLUS comp_expr
   89          | comp_expr • MINUS comp_expr
   90          | comp_expr • MULT comp_expr
   91          | comp_expr • DIV comp_expr
   92          | comp_expr • MOD comp_expr
   93          | comp_expr • GT comp_expr
   94          | comp_expr • LT comp_expr
   94          | comp_expr LT comp_expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, KEYWORD_AND, EQ, NEQ, LT, RBRACKET, RPAREN, COMMA, COLON]
   95          | comp_expr • GEQ comp_expr
   96          | comp_expr • LEQ comp_expr
   97          | comp_expr • EQ comp_expr
   98          | comp_expr • NEQ comp_expr
   99          | comp_expr • KEYWORD_AND comp_expr
  100          | comp_expr • KEYWORD_OR comp_expr
  104          | comp_expr • POW comp_expr

    LEQ    shift, and go to state 270
    GT     shift, and go to state 271
    GEQ    shift, and go to state 272
    PLUS   shift, and go to state 273
    MINUS  shift, and go to state 274
    MULT   shift, and go to state 275
    DIV    shift, and go to state 276
    MOD    shift, and go to state 277
    POW    shift, and go to state 278

    $default  reduce using rule 94 (comp_expr)

    Conflict between rule 94 and token KEYWORD_OR resolved as reduce (KEYWORD_OR < LT).
    Conflict between rule 94 and token KEYWORD_AND resolved as reduce (KEYWORD_AND < LT).
    Conflict between rule 94 and token EQ resolved as reduce (EQ < LT).
    Conflict between rule 94 and token NEQ resolved as reduce (NEQ < LT).
    Conflict between rule 94 and token LT resolved as reduce (%left LT).
    Conflict between rule 94 and token LEQ resolved as shift (LT < LEQ).
    Conflict between rule 94 and token GT resolved as shift (LT < GT).
    Conflict between rule 94 and token GEQ resolved as shift (LT < GEQ).
    Conflict between rule 94 and token PLUS resolved as shift (LT < PLUS).
    Conflict between rule 94 and token MINUS resolved as shift (LT < MINUS).
    Conflict between rule 94 and token MULT resolved as shift (LT < MULT).
    Conflict between rule 94 and token DIV resolved as shift (LT < DIV).
    Conflict between rule 94 and token MOD resolved as shift (LT < MOD).
    Conflict between rule 94 and token POW resolved as shift (LT < POW).


State 304

   88 comp_expr: comp_expr • PLUS comp_expr
   89          | comp_expr • MINUS comp_expr
   90          | comp_expr • MULT comp_expr
   91          | comp_expr • DIV comp_expr
   92          | comp_expr • MOD comp_expr
   93          | comp_expr • GT comp_expr
   94          | comp_expr • LT comp_expr
   95          | comp_expr • GEQ comp_expr
   96          | comp_expr • LEQ comp_expr
   96          | comp_expr LEQ comp_expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, KEYWORD_AND, EQ, NEQ, LT, LEQ, RBRACKET, RPAREN, COMMA, COLON]
   97          | comp_expr • EQ comp_expr
   98          | comp_expr • NEQ comp_expr
   99          | comp_expr • KEYWORD_AND comp_expr
  100          | comp_expr • KEYWORD_OR comp_expr
  104          | comp_expr • POW comp_expr

    GT     shift, and go to state 271
    GEQ    shift, and go to state 272
    PLUS   shift, and go to state 273
    MINUS  shift, and go to state 274
    MULT   shift, and go to state 275
    DIV    shift, and go to state 276
    MOD    shift, and go to state 277
    POW    shift, and go to state 278

    $default  reduce using rule 96 (comp_expr)

    Conflict between rule 96 and token KEYWORD_OR resolved as reduce (KEYWORD_OR < LEQ).
    Conflict between rule 96 and token KEYWORD_AND resolved as reduce (KEYWORD_AND < LEQ).
    Conflict between rule 96 and token EQ resolved as reduce (EQ < LEQ).
    Conflict between rule 96 and token NEQ resolved as reduce (NEQ < LEQ).
    Conflict between rule 96 and token LT resolved as reduce (LT < LEQ).
    Conflict between rule 96 and token LEQ resolved as reduce (%left LEQ).
    Conflict between rule 96 and token GT resolved as shift (LEQ < GT).
    Conflict between rule 96 and token GEQ resolved as shift (LEQ < GEQ).
    Conflict between rule 96 and token PLUS resolved as shift (LEQ < PLUS).
    Conflict between rule 96 and token MINUS resolved as shift (LEQ < MINUS).
    Conflict between rule 96 and token MULT resolved as shift (LEQ < MULT).
    Conflict between rule 96 and token DIV resolved as shift (LEQ < DIV).
    Conflict between rule 96 and token MOD resolved as shift (LEQ < MOD).
    Conflict between rule 96 and token POW resolved as shift (LEQ < POW).


State 305

   88 comp_expr: comp_expr • PLUS comp_expr
   89          | comp_expr • MINUS comp_expr
   90          | comp_expr • MULT comp_expr
   91          | comp_expr • DIV comp_expr
   92          | comp_expr • MOD comp_expr
   93          | comp_expr • GT comp_expr
   93          | comp_expr GT comp_expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, KEYWORD_AND, EQ, NEQ, LT, LEQ, GT, RBRACKET, RPAREN, COMMA, COLON]
   94          | comp_expr • LT comp_expr
   95          | comp_expr • GEQ comp_expr
   96          | comp_expr • LEQ comp_expr
   97          | comp_expr • EQ comp_expr
   98          | comp_expr • NEQ comp_expr
   99          | comp_expr • KEYWORD_AND comp_expr
  100          | comp_expr • KEYWORD_OR comp_expr
  104          | comp_expr • POW comp_expr

    GEQ    shift, and go to state 272
    PLUS   shift, and go to state 273
    MINUS  shift, and go to state 274
    MULT   shift, and go to state 275
    DIV    shift, and go to state 276
    MOD    shift, and go to state 277
    POW    shift, and go to state 278

    $default  reduce using rule 93 (comp_expr)

    Conflict between rule 93 and token KEYWORD_OR resolved as reduce (KEYWORD_OR < GT).
    Conflict between rule 93 and token KEYWORD_AND resolved as reduce (KEYWORD_AND < GT).
    Conflict between rule 93 and token EQ resolved as reduce (EQ < GT).
    Conflict between rule 93 and token NEQ resolved as reduce (NEQ < GT).
    Conflict between rule 93 and token LT resolved as reduce (LT < GT).
    Conflict between rule 93 and token LEQ resolved as reduce (LEQ < GT).
    Conflict between rule 93 and token GT resolved as reduce (%left GT).
    Conflict between rule 93 and token GEQ resolved as shift (GT < GEQ).
    Conflict between rule 93 and token PLUS resolved as shift (GT < PLUS).
    Conflict between rule 93 and token MINUS resolved as shift (GT < MINUS).
    Conflict between rule 93 and token MULT resolved as shift (GT < MULT).
    Conflict between rule 93 and token DIV resolved as shift (GT < DIV).
    Conflict between rule 93 and token MOD resolved as shift (GT < MOD).
    Conflict between rule 93 and token POW resolved as shift (GT < POW).


State 306

   88 comp_expr: comp_expr • PLUS comp_expr
   89          | comp_expr • MINUS comp_expr
   90          | comp_expr • MULT comp_expr
   91          | comp_expr • DIV comp_expr
   92          | comp_expr • MOD comp_expr
   93          | comp_expr • GT comp_expr
   94          | comp_expr • LT comp_expr
   95          | comp_expr • GEQ comp_expr
   95          | comp_expr GEQ comp_expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, KEYWORD_AND, EQ, NEQ, LT, LEQ, GT, GEQ, RBRACKET, RPAREN, COMMA, COLON]
   96          | comp_expr • LEQ comp_expr
   97          | comp_expr • EQ comp_expr
   98          | comp_expr • NEQ comp_expr
   99          | comp_expr • KEYWORD_AND comp_expr
  100          | comp_expr • KEYWORD_OR comp_expr
  104          | comp_expr • POW comp_expr

    PLUS   shift, and go to state 273
    MINUS  shift, and go to state 274
    MULT   shift, and go to state 275
    DIV    shift, and go to state 276
    MOD    shift, and go to state 277
    POW    shift, and go to state 278

    $default  reduce using rule 95 (comp_expr)

    Conflict between rule 95 and token KEYWORD_OR resolved as reduce (KEYWORD_OR < GEQ).
    Conflict between rule 95 and token KEYWORD_AND resolved as reduce (KEYWORD_AND < GEQ).
    Conflict between rule 95 and token EQ resolved as reduce (EQ < GEQ).
    Conflict between rule 95 and token NEQ resolved as reduce (NEQ < GEQ).
    Conflict between rule 95 and token LT resolved as reduce (LT < GEQ).
    Conflict between rule 95 and token LEQ resolved as reduce (LEQ < GEQ).
    Conflict between rule 95 and token GT resolved as reduce (GT < GEQ).
    Conflict between rule 95 and token GEQ resolved as reduce (%left GEQ).
    Conflict between rule 95 and token PLUS resolved as shift (GEQ < PLUS).
    Conflict between rule 95 and token MINUS resolved as shift (GEQ < MINUS).
    Conflict between rule 95 and token MULT resolved as shift (GEQ < MULT).
    Conflict between rule 95 and token DIV resolved as shift (GEQ < DIV).
    Conflict between rule 95 and token MOD resolved as shift (GEQ < MOD).
    Conflict between rule 95 and token POW resolved as shift (GEQ < POW).


State 307

   88 comp_expr: comp_expr • PLUS comp_expr
   88          | comp_expr PLUS comp_expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, KEYWORD_AND, EQ, NEQ, LT, LEQ, GT, GEQ, PLUS, RBRACKET, RPAREN, COMMA, COLON]
   89          | comp_expr • MINUS comp_expr
   90          | comp_expr • MULT comp_expr
   91          | comp_expr • DIV comp_expr
   92          | comp_expr • MOD comp_expr
   93          | comp_expr • GT comp_expr
   94          | comp_expr • LT comp_expr
   95          | comp_expr • GEQ comp_expr
   96          | comp_expr • LEQ comp_expr
   97          | comp_expr • EQ comp_expr
   98          | comp_expr • NEQ comp_expr
   99          | comp_expr • KEYWORD_AND comp_expr
  100          | comp_expr • KEYWORD_OR comp_expr
  104          | comp_expr • POW comp_expr

    MINUS  shift, and go to state 274
    MULT   shift, and go to state 275
    DIV    shift, and go to state 276
    MOD    shift, and go to state 277
    POW    shift, and go to state 278

    $default  reduce using rule 88 (comp_expr)

    Conflict between rule 88 and token KEYWORD_OR resolved as reduce (KEYWORD_OR < PLUS).
    Conflict between rule 88 and token KEYWORD_AND resolved as reduce (KEYWORD_AND < PLUS).
    Conflict between rule 88 and token EQ resolved as reduce (EQ < PLUS).
    Conflict between rule 88 and token NEQ resolved as reduce (NEQ < PLUS).
    Conflict between rule 88 and token LT resolved as reduce (LT < PLUS).
    Conflict between rule 88 and token LEQ resolved as reduce (LEQ < PLUS).
    Conflict between rule 88 and token GT resolved as reduce (GT < PLUS).
    Conflict between rule 88 and token GEQ resolved as reduce (GEQ < PLUS).
    Conflict between rule 88 and token PLUS resolved as reduce (%left PLUS).
    Conflict between rule 88 and token MINUS resolved as shift (PLUS < MINUS).
    Conflict between rule 88 and token MULT resolved as shift (PLUS < MULT).
    Conflict between rule 88 and token DIV resolved as shift (PLUS < DIV).
    Conflict between rule 88 and token MOD resolved as shift (PLUS < MOD).
    Conflict between rule 88 and token POW resolved as shift (PLUS < POW).


State 308

   88 comp_expr: comp_expr • PLUS comp_expr
   89          | comp_expr • MINUS comp_expr
   89          | comp_expr MINUS comp_expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, KEYWORD_AND, EQ, NEQ, LT, LEQ, GT, GEQ, PLUS, MINUS, RBRACKET, RPAREN, COMMA, COLON]
   90          | comp_expr • MULT comp_expr
   91          | comp_expr • DIV comp_expr
   92          | comp_expr • MOD comp_expr
   93          | comp_expr • GT comp_expr
   94          | comp_expr • LT comp_expr
   95          | comp_expr • GEQ comp_expr
   96          | comp_expr • LEQ comp_expr
   97          | comp_expr • EQ comp_expr
   98          | comp_expr • NEQ comp_expr
   99          | comp_expr • KEYWORD_AND comp_expr
  100          | comp_expr • KEYWORD_OR comp_expr
  104          | comp_expr • POW comp_expr

    MULT  shift, and go to state 275
    DIV   shift, and go to state 276
    MOD   shift, and go to state 277
    POW   shift, and go to state 278

    $default  reduce using rule 89 (comp_expr)

    Conflict between rule 89 and token KEYWORD_OR resolved as reduce (KEYWORD_OR < MINUS).
    Conflict between rule 89 and token KEYWORD_AND resolved as reduce (KEYWORD_AND < MINUS).
    Conflict between rule 89 and token EQ resolved as reduce (EQ < MINUS).
    Conflict between rule 89 and token NEQ resolved as reduce (NEQ < MINUS).
    Conflict between rule 89 and token LT resolved as reduce (LT < MINUS).
    Conflict between rule 89 and token LEQ resolved as reduce (LEQ < MINUS).
    Conflict between rule 89 and token GT resolved as reduce (GT < MINUS).
    Conflict between rule 89 and token GEQ resolved as reduce (GEQ < MINUS).
    Conflict between rule 89 and token PLUS resolved as reduce (PLUS < MINUS).
    Conflict between rule 89 and token MINUS resolved as reduce (%left MINUS).
    Conflict between rule 89 and token MULT resolved as shift (MINUS < MULT).
    Conflict between rule 89 and token DIV resolved as shift (MINUS < DIV).
    Conflict between rule 89 and token MOD resolved as shift (MINUS < MOD).
    Conflict between rule 89 and token POW resolved as shift (MINUS < POW).


State 309

   88 comp_expr: comp_expr • PLUS comp_expr
   89          | comp_expr • MINUS comp_expr
   90          | comp_expr • MULT comp_expr
   90          | comp_expr MULT comp_expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, KEYWORD_AND, EQ, NEQ, LT, LEQ, GT, GEQ, PLUS, MINUS, MULT, RBRACKET, RPAREN, COMMA, COLON]
   91          | comp_expr • DIV comp_expr
   92          | comp_expr • MOD comp_expr
   93          | comp_expr • GT comp_expr
   94          | comp_expr • LT comp_expr
   95          | comp_expr • GEQ comp_expr
   96          | comp_expr • LEQ comp_expr
   97          | comp_expr • EQ comp_expr
   98          | comp_expr • NEQ comp_expr
   99          | comp_expr • KEYWORD_AND comp_expr
  100          | comp_expr • KEYWORD_OR comp_expr
  104          | comp_expr • POW comp_expr

    DIV  shift, and go to state 276
    MOD  shift, and go to state 277
    POW  shift, and go to state 278

    $default  reduce using rule 90 (comp_expr)

    Conflict between rule 90 and token KEYWORD_OR resolved as reduce (KEYWORD_OR < MULT).
    Conflict between rule 90 and token KEYWORD_AND resolved as reduce (KEYWORD_AND < MULT).
    Conflict between rule 90 and token EQ resolved as reduce (EQ < MULT).
    Conflict between rule 90 and token NEQ resolved as reduce (NEQ < MULT).
    Conflict between rule 90 and token LT resolved as reduce (LT < MULT).
    Conflict between rule 90 and token LEQ resolved as reduce (LEQ < MULT).
    Conflict between rule 90 and token GT resolved as reduce (GT < MULT).
    Conflict between rule 90 and token GEQ resolved as reduce (GEQ < MULT).
    Conflict between rule 90 and token PLUS resolved as reduce (PLUS < MULT).
    Conflict between rule 90 and token MINUS resolved as reduce (MINUS < MULT).
    Conflict between rule 90 and token MULT resolved as reduce (%left MULT).
    Conflict between rule 90 and token DIV resolved as shift (MULT < DIV).
    Conflict between rule 90 and token MOD resolved as shift (MULT < MOD).
    Conflict between rule 90 and token POW resolved as shift (MULT < POW).


State 310

   88 comp_expr: comp_expr • PLUS comp_expr
   89          | comp_expr • MINUS comp_expr
   90          | comp_expr • MULT comp_expr
   91          | comp_expr • DIV comp_expr
   91          | comp_expr DIV comp_expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, KEYWORD_AND, EQ, NEQ, LT, LEQ, GT, GEQ, PLUS, MINUS, MULT, DIV, RBRACKET, RPAREN, COMMA, COLON]
   92          | comp_expr • MOD comp_expr
   93          | comp_expr • GT comp_expr
   94          | comp_expr • LT comp_expr
   95          | comp_expr • GEQ comp_expr
   96          | comp_expr • LEQ comp_expr
   97          | comp_expr • EQ comp_expr
   98          | comp_expr • NEQ comp_expr
   99          | comp_expr • KEYWORD_AND comp_expr
  100          | comp_expr • KEYWORD_OR comp_expr
  104          | comp_expr • POW comp_expr

    MOD  shift, and go to state 277
    POW  shift, and go to state 278

    $default  reduce using rule 91 (comp_expr)

    Conflict between rule 91 and token KEYWORD_OR resolved as reduce (KEYWORD_OR < DIV).
    Conflict between rule 91 and token KEYWORD_AND resolved as reduce (KEYWORD_AND < DIV).
    Conflict between rule 91 and token EQ resolved as reduce (EQ < DIV).
    Conflict between rule 91 and token NEQ resolved as reduce (NEQ < DIV).
    Conflict between rule 91 and token LT resolved as reduce (LT < DIV).
    Conflict between rule 91 and token LEQ resolved as reduce (LEQ < DIV).
    Conflict between rule 91 and token GT resolved as reduce (GT < DIV).
    Conflict between rule 91 and token GEQ resolved as reduce (GEQ < DIV).
    Conflict between rule 91 and token PLUS resolved as reduce (PLUS < DIV).
    Conflict between rule 91 and token MINUS resolved as reduce (MINUS < DIV).
    Conflict between rule 91 and token MULT resolved as reduce (MULT < DIV).
    Conflict between rule 91 and token DIV resolved as reduce (%left DIV).
    Conflict between rule 91 and token MOD resolved as shift (DIV < MOD).
    Conflict between rule 91 and token POW resolved as shift (DIV < POW).


State 311

   88 comp_expr: comp_expr • PLUS comp_expr
   89          | comp_expr • MINUS comp_expr
   90          | comp_expr • MULT comp_expr
   91          | comp_expr • DIV comp_expr
   92          | comp_expr • MOD comp_expr
   92          | comp_expr MOD comp_expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, KEYWORD_AND, EQ, NEQ, LT, LEQ, GT, GEQ, PLUS, MINUS, MULT, DIV, MOD, RBRACKET, RPAREN, COMMA, COLON]
   93          | comp_expr • GT comp_expr
   94          | comp_expr • LT comp_expr
   95          | comp_expr • GEQ comp_expr
   96          | comp_expr • LEQ comp_expr
   97          | comp_expr • EQ comp_expr
   98          | comp_expr • NEQ comp_expr
   99          | comp_expr • KEYWORD_AND comp_expr
  100          | comp_expr • KEYWORD_OR comp_expr
  104          | comp_expr • POW comp_expr

    POW  shift, and go to state 278

    $default  reduce using rule 92 (comp_expr)

    Conflict between rule 92 and token KEYWORD_OR resolved as reduce (KEYWORD_OR < MOD).
    Conflict between rule 92 and token KEYWORD_AND resolved as reduce (KEYWORD_AND < MOD).
    Conflict between rule 92 and token EQ resolved as reduce (EQ < MOD).
    Conflict between rule 92 and token NEQ resolved as reduce (NEQ < MOD).
    Conflict between rule 92 and token LT resolved as reduce (LT < MOD).
    Conflict between rule 92 and token LEQ resolved as reduce (LEQ < MOD).
    Conflict between rule 92 and token GT resolved as reduce (GT < MOD).
    Conflict between rule 92 and token GEQ resolved as reduce (GEQ < MOD).
    Conflict between rule 92 and token PLUS resolved as reduce (PLUS < MOD).
    Conflict between rule 92 and token MINUS resolved as reduce (MINUS < MOD).
    Conflict between rule 92 and token MULT resolved as reduce (MULT < MOD).
    Conflict between rule 92 and token DIV resolved as reduce (DIV < MOD).
    Conflict between rule 92 and token MOD resolved as reduce (%left MOD).
    Conflict between rule 92 and token POW resolved as shift (MOD < POW).


State 312

   88 comp_expr: comp_expr • PLUS comp_expr
   89          | comp_expr • MINUS comp_expr
   90          | comp_expr • MULT comp_expr
   91          | comp_expr • DIV comp_expr
   92          | comp_expr • MOD comp_expr
   93          | comp_expr • GT comp_expr
   94          | comp_expr • LT comp_expr
   95          | comp_expr • GEQ comp_expr
   96          | comp_expr • LEQ comp_expr
   97          | comp_expr • EQ comp_expr
   98          | comp_expr • NEQ comp_expr
   99          | comp_expr • KEYWORD_AND comp_expr
  100          | comp_expr • KEYWORD_OR comp_expr
  104          | comp_expr • POW comp_expr
  104          | comp_expr POW comp_expr •  [KEYWORD_FOR, SEMICOLON, KEYWORD_OR, KEYWORD_AND, EQ, NEQ, LT, LEQ, GT, GEQ, PLUS, MINUS, MULT, DIV, MOD, RBRACKET, RPAREN, COMMA, COLON]

    POW  shift, and go to state 278

    $default  reduce using rule 104 (comp_expr)

    Conflict between rule 104 and token KEYWORD_OR resolved as reduce (KEYWORD_OR < POW).
    Conflict between rule 104 and token KEYWORD_AND resolved as reduce (KEYWORD_AND < POW).
    Conflict between rule 104 and token EQ resolved as reduce (EQ < POW).
    Conflict between rule 104 and token NEQ resolved as reduce (NEQ < POW).
    Conflict between rule 104 and token LT resolved as reduce (LT < POW).
    Conflict between rule 104 and token LEQ resolved as reduce (LEQ < POW).
    Conflict between rule 104 and token GT resolved as reduce (GT < POW).
    Conflict between rule 104 and token GEQ resolved as reduce (GEQ < POW).
    Conflict between rule 104 and token PLUS resolved as reduce (PLUS < POW).
    Conflict between rule 104 and token MINUS resolved as reduce (MINUS < POW).
    Conflict between rule 104 and token MULT resolved as reduce (MULT < POW).
    Conflict between rule 104 and token DIV resolved as reduce (DIV < POW).
    Conflict between rule 104 and token MOD resolved as reduce (MOD < POW).
    Conflict between rule 104 and token POW resolved as shift (%right POW).


State 313

   72 comp_assign_stmt: comp_var_name ASSIGN comp_expr SEMICOLON •

    $default  reduce using rule 72 (comp_assign_stmt)


State 314

   73 comp_assign_stmt: comp_var_name PLUS_ASSIGN comp_expr SEMICOLON •

    $default  reduce using rule 73 (comp_assign_stmt)


State 315

   74 comp_assign_stmt: comp_var_name MINUS_ASSIGN comp_expr SEMICOLON •

    $default  reduce using rule 74 (comp_assign_stmt)


State 316

   67 comp_range_comprehension: comp_var_name COLON_ASSIGN LBRACKET comp_expr • KEYWORD_FOR comp_var_name COLON INTEGER RBRACKET COLON var_type SEMICOLON
   68 comp_arr_comprehension: comp_var_name COLON_ASSIGN LBRACKET comp_expr • KEYWORD_FOR comp_var_name COLON var_type KEYWORD_IN comp_var_name KEYWORD_OF INTEGER RBRACKET COLON var_type SEMICOLON
   88 comp_expr: comp_expr • PLUS comp_expr
   89          | comp_expr • MINUS comp_expr
   90          | comp_expr • MULT comp_expr
   91          | comp_expr • DIV comp_expr
   92          | comp_expr • MOD comp_expr
   93          | comp_expr • GT comp_expr
   94          | comp_expr • LT comp_expr
   95          | comp_expr • GEQ comp_expr
   96          | comp_expr • LEQ comp_expr
   97          | comp_expr • EQ comp_expr
   98          | comp_expr • NEQ comp_expr
   99          | comp_expr • KEYWORD_AND comp_expr
  100          | comp_expr • KEYWORD_OR comp_expr
  104          | comp_expr • POW comp_expr

    KEYWORD_FOR  shift, and go to state 338
    KEYWORD_OR   shift, and go to state 265
    KEYWORD_AND  shift, and go to state 266
    EQ           shift, and go to state 267
    NEQ          shift, and go to state 268
    LT           shift, and go to state 269
    LEQ          shift, and go to state 270
    GT           shift, and go to state 271
    GEQ          shift, and go to state 272
    PLUS         shift, and go to state 273
    MINUS        shift, and go to state 274
    MULT         shift, and go to state 275
    DIV          shift, and go to state 276
    MOD          shift, and go to state 277
    POW          shift, and go to state 278


State 317

   78 comp_assign_stmt: comp_var_name COLON_ASSIGN comp_expr SEMICOLON •

    $default  reduce using rule 78 (comp_assign_stmt)


State 318

   75 comp_assign_stmt: comp_var_name MULT_ASSIGN comp_expr SEMICOLON •

    $default  reduce using rule 75 (comp_assign_stmt)


State 319

   76 comp_assign_stmt: comp_var_name DIV_ASSIGN comp_expr SEMICOLON •

    $default  reduce using rule 76 (comp_assign_stmt)


State 320

   77 comp_assign_stmt: comp_var_name MOD_ASSIGN comp_expr SEMICOLON •

    $default  reduce using rule 77 (comp_assign_stmt)


State 321

   83 comp_func_call: comp_var_name LPAREN comp_expr_list RPAREN •

    $default  reduce using rule 83 (comp_func_call)


State 322

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   86 comp_expr_list: comp_expr_list COMMA • comp_expr
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 225
    PLUS           shift, and go to state 226
    MINUS          shift, and go to state 227
    LPAREN         shift, and go to state 228

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 339
    operand    go to state 230
    func_call  go to state 51


State 323

   14 func_header: KEYWORD_DEF IDENTIFIER LPAREN func_param_list RPAREN MINUS GT var_type COLON •

    $default  reduce using rule 14 (func_header)


State 324

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
  136 stmts: stmts • stmt
  137 stmt: • empty_stmt
  138     | • if_stmt
  139     | • func_call SEMICOLON
  140     | • return_stmt
  141     | • break_stmt
  142     | • continue_stmt
  143     | • while_stmt
  144     | • for_stmt
  145     | • assign_stmt
  146     | • range_comprehension
  147     | • arr_comprehension
  148 range_comprehension: • var_name COLON_ASSIGN LBRACKET expr KEYWORD_FOR var_name COLON INTEGER RBRACKET COLON var_type SEMICOLON
  149 arr_comprehension: • var_name COLON_ASSIGN LBRACKET expr KEYWORD_FOR var_name COLON var_type KEYWORD_IN var_name KEYWORD_OF INTEGER RBRACKET COLON var_type SEMICOLON
  150 for_stmt: • KEYWORD_FOR var_name KEYWORD_IN LBRACKET expr COLON expr COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON
  151         | • KEYWORD_FOR var_name KEYWORD_IN LBRACKET expr COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON
  152 while_stmt: • KEYWORD_WHILE LPAREN expr RPAREN COLON stmts KEYWORD_ENDWHILE SEMICOLON
  153 assign_stmt: • var_name ASSIGN expr SEMICOLON
  154            | • var_name PLUS_ASSIGN expr SEMICOLON
  155            | • var_name MINUS_ASSIGN expr SEMICOLON
  156            | • var_name MULT_ASSIGN expr SEMICOLON
  157            | • var_name DIV_ASSIGN expr SEMICOLON
  158            | • var_name MOD_ASSIGN expr SEMICOLON
  159            | • var_name COLON_ASSIGN expr SEMICOLON
  160 return_stmt: • KEYWORD_RETURN SEMICOLON
  161            | • KEYWORD_RETURN expr SEMICOLON
  162 break_stmt: • KEYWORD_BREAK SEMICOLON
  163 continue_stmt: • KEYWORD_CONTINUE SEMICOLON
  164 empty_stmt: • SEMICOLON
  165 if_stmt: • KEYWORD_IF LPAREN expr RPAREN COLON stmts KEYWORD_ENDIF SEMICOLON
  165        | KEYWORD_IF LPAREN expr RPAREN COLON stmts • KEYWORD_ENDIF SEMICOLON
  166        | • KEYWORD_IF LPAREN expr RPAREN COLON stmts KEYWORD_ELSE COLON stmts KEYWORD_ENDIF SEMICOLON
  166        | KEYWORD_IF LPAREN expr RPAREN COLON stmts • KEYWORD_ELSE COLON stmts KEYWORD_ENDIF SEMICOLON
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_IF        shift, and go to state 128
    KEYWORD_ELSE      shift, and go to state 340
    KEYWORD_ENDIF     shift, and go to state 341
    KEYWORD_FOR       shift, and go to state 129
    KEYWORD_WHILE     shift, and go to state 130
    KEYWORD_BREAK     shift, and go to state 131
    KEYWORD_CONTINUE  shift, and go to state 132
    KEYWORD_RETURN    shift, and go to state 133
    IDENTIFIER        shift, and go to state 39
    SEMICOLON         shift, and go to state 134

    var_name             go to state 175
    stmt                 go to state 176
    range_comprehension  go to state 138
    arr_comprehension    go to state 139
    for_stmt             go to state 140
    while_stmt           go to state 141
    assign_stmt          go to state 142
    return_stmt          go to state 143
    break_stmt           go to state 144
    continue_stmt        go to state 145
    empty_stmt           go to state 146
    if_stmt              go to state 147
    func_call            go to state 148


State 325

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  150 for_stmt: KEYWORD_FOR var_name KEYWORD_IN LBRACKET expr COLON • expr COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON
  151         | KEYWORD_FOR var_name KEYWORD_IN LBRACKET expr COLON • expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 43
    PLUS           shift, and go to state 44
    MINUS          shift, and go to state 45
    LPAREN         shift, and go to state 46

    var_name   go to state 47
    bool_dt    go to state 48
    expr       go to state 342
    operand    go to state 50
    func_call  go to state 51


State 326

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
  136 stmts: stmts • stmt
  137 stmt: • empty_stmt
  138     | • if_stmt
  139     | • func_call SEMICOLON
  140     | • return_stmt
  141     | • break_stmt
  142     | • continue_stmt
  143     | • while_stmt
  144     | • for_stmt
  145     | • assign_stmt
  146     | • range_comprehension
  147     | • arr_comprehension
  148 range_comprehension: • var_name COLON_ASSIGN LBRACKET expr KEYWORD_FOR var_name COLON INTEGER RBRACKET COLON var_type SEMICOLON
  149 arr_comprehension: • var_name COLON_ASSIGN LBRACKET expr KEYWORD_FOR var_name COLON var_type KEYWORD_IN var_name KEYWORD_OF INTEGER RBRACKET COLON var_type SEMICOLON
  150 for_stmt: • KEYWORD_FOR var_name KEYWORD_IN LBRACKET expr COLON expr COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON
  151         | • KEYWORD_FOR var_name KEYWORD_IN LBRACKET expr COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON
  152 while_stmt: • KEYWORD_WHILE LPAREN expr RPAREN COLON stmts KEYWORD_ENDWHILE SEMICOLON
  152           | KEYWORD_WHILE LPAREN expr RPAREN COLON stmts • KEYWORD_ENDWHILE SEMICOLON
  153 assign_stmt: • var_name ASSIGN expr SEMICOLON
  154            | • var_name PLUS_ASSIGN expr SEMICOLON
  155            | • var_name MINUS_ASSIGN expr SEMICOLON
  156            | • var_name MULT_ASSIGN expr SEMICOLON
  157            | • var_name DIV_ASSIGN expr SEMICOLON
  158            | • var_name MOD_ASSIGN expr SEMICOLON
  159            | • var_name COLON_ASSIGN expr SEMICOLON
  160 return_stmt: • KEYWORD_RETURN SEMICOLON
  161            | • KEYWORD_RETURN expr SEMICOLON
  162 break_stmt: • KEYWORD_BREAK SEMICOLON
  163 continue_stmt: • KEYWORD_CONTINUE SEMICOLON
  164 empty_stmt: • SEMICOLON
  165 if_stmt: • KEYWORD_IF LPAREN expr RPAREN COLON stmts KEYWORD_ENDIF SEMICOLON
  166        | • KEYWORD_IF LPAREN expr RPAREN COLON stmts KEYWORD_ELSE COLON stmts KEYWORD_ENDIF SEMICOLON
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_IF        shift, and go to state 128
    KEYWORD_FOR       shift, and go to state 129
    KEYWORD_WHILE     shift, and go to state 130
    KEYWORD_ENDWHILE  shift, and go to state 343
    KEYWORD_BREAK     shift, and go to state 131
    KEYWORD_CONTINUE  shift, and go to state 132
    KEYWORD_RETURN    shift, and go to state 133
    IDENTIFIER        shift, and go to state 39
    SEMICOLON         shift, and go to state 134

    var_name             go to state 175
    stmt                 go to state 176
    range_comprehension  go to state 138
    arr_comprehension    go to state 139
    for_stmt             go to state 140
    while_stmt           go to state 141
    assign_stmt          go to state 142
    return_stmt          go to state 143
    break_stmt           go to state 144
    continue_stmt        go to state 145
    empty_stmt           go to state 146
    if_stmt              go to state 147
    func_call            go to state 148


State 327

  148 range_comprehension: var_name COLON_ASSIGN LBRACKET expr KEYWORD_FOR var_name • COLON INTEGER RBRACKET COLON var_type SEMICOLON
  149 arr_comprehension: var_name COLON_ASSIGN LBRACKET expr KEYWORD_FOR var_name • COLON var_type KEYWORD_IN var_name KEYWORD_OF INTEGER RBRACKET COLON var_type SEMICOLON

    COLON  shift, and go to state 344


State 328

   42 comp_func_header: KEYWORD_DEF IDENTIFIER LPAREN comp_func_param_list RPAREN MINUS GT var_type • COLON

    COLON  shift, and go to state 345


State 329

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   52 comp_var_name: • HASHTAG var_name
   53              | • var_name
   54 comp_stmts: • comp_stmt
   55           | • comp_stmts comp_stmt
   56 comp_stmt: • empty_stmt
   57          | • comp_if_stmt
   58          | • comp_func_call SEMICOLON
   59          | • comp_return_stmt
   60          | • break_stmt
   61          | • continue_stmt
   62          | • comp_while_stmt
   63          | • comp_for_stmt
   64          | • comp_assign_stmt
   65          | • comp_range_comprehension
   66          | • comp_arr_comprehension
   67 comp_range_comprehension: • comp_var_name COLON_ASSIGN LBRACKET comp_expr KEYWORD_FOR comp_var_name COLON INTEGER RBRACKET COLON var_type SEMICOLON
   68 comp_arr_comprehension: • comp_var_name COLON_ASSIGN LBRACKET comp_expr KEYWORD_FOR comp_var_name COLON var_type KEYWORD_IN comp_var_name KEYWORD_OF INTEGER RBRACKET COLON var_type SEMICOLON
   69 comp_for_stmt: • KEYWORD_FOR comp_var_name KEYWORD_IN LBRACKET comp_expr COLON comp_expr COLON comp_expr RBRACKET COLON comp_stmts KEYWORD_ENDFOR SEMICOLON
   70              | • KEYWORD_FOR comp_var_name KEYWORD_IN LBRACKET expr COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON
   71 comp_while_stmt: • KEYWORD_WHILE LPAREN comp_expr RPAREN COLON comp_stmts KEYWORD_ENDWHILE SEMICOLON
   72 comp_assign_stmt: • comp_var_name ASSIGN comp_expr SEMICOLON
   73                 | • comp_var_name PLUS_ASSIGN comp_expr SEMICOLON
   74                 | • comp_var_name MINUS_ASSIGN comp_expr SEMICOLON
   75                 | • comp_var_name MULT_ASSIGN comp_expr SEMICOLON
   76                 | • comp_var_name DIV_ASSIGN comp_expr SEMICOLON
   77                 | • comp_var_name MOD_ASSIGN comp_expr SEMICOLON
   78                 | • comp_var_name COLON_ASSIGN comp_expr SEMICOLON
   79 comp_return_stmt: • KEYWORD_RETURN SEMICOLON
   80                 | • KEYWORD_RETURN comp_expr SEMICOLON
   81 comp_if_stmt: • KEYWORD_IF LPAREN comp_expr RPAREN COLON comp_stmts KEYWORD_ENDIF SEMICOLON
   81             | KEYWORD_IF LPAREN comp_expr RPAREN COLON • comp_stmts KEYWORD_ENDIF SEMICOLON
   82             | • KEYWORD_IF LPAREN comp_expr RPAREN COLON comp_stmts KEYWORD_ELSE COLON comp_stmts KEYWORD_ENDIF SEMICOLON
   82             | KEYWORD_IF LPAREN comp_expr RPAREN COLON • comp_stmts KEYWORD_ELSE COLON comp_stmts KEYWORD_ENDIF SEMICOLON
   83 comp_func_call: • comp_var_name LPAREN comp_expr_list RPAREN
  162 break_stmt: • KEYWORD_BREAK SEMICOLON
  163 continue_stmt: • KEYWORD_CONTINUE SEMICOLON
  164 empty_stmt: • SEMICOLON

    KEYWORD_IF        shift, and go to state 180
    KEYWORD_FOR       shift, and go to state 181
    KEYWORD_WHILE     shift, and go to state 182
    KEYWORD_BREAK     shift, and go to state 131
    KEYWORD_CONTINUE  shift, and go to state 132
    KEYWORD_RETURN    shift, and go to state 183
    IDENTIFIER        shift, and go to state 13
    HASHTAG           shift, and go to state 184
    SEMICOLON         shift, and go to state 134

    var_name                  go to state 221
    comp_var_name             go to state 186
    comp_stmts                go to state 346
    comp_stmt                 go to state 188
    comp_range_comprehension  go to state 189
    comp_arr_comprehension    go to state 190
    comp_for_stmt             go to state 191
    comp_while_stmt           go to state 192
    comp_assign_stmt          go to state 193
    comp_return_stmt          go to state 194
    comp_if_stmt              go to state 195
    comp_func_call            go to state 196
    break_stmt                go to state 197
    continue_stmt             go to state 198
    empty_stmt                go to state 199


State 330

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  101          | KEYWORD_NOT • comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  121     | KEYWORD_NOT • expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 330
    PLUS           shift, and go to state 331
    MINUS          shift, and go to state 332
    LPAREN         shift, and go to state 333

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 260
    expr       go to state 73
    operand    go to state 336
    func_call  go to state 51


State 331

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  102          | PLUS • comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  122     | PLUS • expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 330
    PLUS           shift, and go to state 331
    MINUS          shift, and go to state 332
    LPAREN         shift, and go to state 333

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 261
    expr       go to state 74
    operand    go to state 336
    func_call  go to state 51


State 332

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  103          | MINUS • comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  123     | MINUS • expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 330
    PLUS           shift, and go to state 331
    MINUS          shift, and go to state 332
    LPAREN         shift, and go to state 333

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 262
    expr       go to state 75
    operand    go to state 336
    func_call  go to state 51


State 333

   26 var_name: • IDENTIFIER
   27         | • IDENTIFIER LBRACKET expr RBRACKET
   34 bool_dt: • KEYWORD_TRUE
   35        | • KEYWORD_FALSE
   87 comp_expr: • operand
   88          | • comp_expr PLUS comp_expr
   89          | • comp_expr MINUS comp_expr
   90          | • comp_expr MULT comp_expr
   91          | • comp_expr DIV comp_expr
   92          | • comp_expr MOD comp_expr
   93          | • comp_expr GT comp_expr
   94          | • comp_expr LT comp_expr
   95          | • comp_expr GEQ comp_expr
   96          | • comp_expr LEQ comp_expr
   97          | • comp_expr EQ comp_expr
   98          | • comp_expr NEQ comp_expr
   99          | • comp_expr KEYWORD_AND comp_expr
  100          | • comp_expr KEYWORD_OR comp_expr
  101          | • KEYWORD_NOT comp_expr
  102          | • PLUS comp_expr
  103          | • MINUS comp_expr
  104          | • comp_expr POW comp_expr
  105          | • LPAREN comp_expr RPAREN
  105          | LPAREN • comp_expr RPAREN
  107 expr: • operand
  108     | • expr PLUS expr
  109     | • expr MINUS expr
  110     | • expr MULT expr
  111     | • expr DIV expr
  112     | • expr MOD expr
  113     | • expr GT expr
  114     | • expr LT expr
  115     | • expr GEQ expr
  116     | • expr LEQ expr
  117     | • expr EQ expr
  118     | • expr NEQ expr
  119     | • expr KEYWORD_AND expr
  120     | • expr KEYWORD_OR expr
  121     | • KEYWORD_NOT expr
  122     | • PLUS expr
  123     | • MINUS expr
  124     | • expr POW expr
  125     | • LPAREN expr RPAREN
  125     | LPAREN • expr RPAREN
  126 operand: • var_name
  127        | • func_call
  128        | • INTEGER
  129        | • FLOAT
  130        | • bool_dt
  131        | • CONST_STRING
  167 func_call: • IDENTIFIER LPAREN expr_list RPAREN

    KEYWORD_TRUE   shift, and go to state 37
    KEYWORD_FALSE  shift, and go to state 38
    IDENTIFIER     shift, and go to state 39
    INTEGER        shift, and go to state 40
    FLOAT          shift, and go to state 41
    CONST_STRING   shift, and go to state 42
    KEYWORD_NOT    shift, and go to state 330
    PLUS           shift, and go to state 331
    MINUS          shift, and go to state 332
    LPAREN         shift, and go to state 333

    var_name   go to state 47
    bool_dt    go to state 48
    comp_expr  go to state 263
    expr       go to state 76
    operand    go to state 336
    func_call  go to state 51


State 334

   69 comp_for_stmt: KEYWORD_FOR comp_var_name KEYWORD_IN LBRACKET comp_expr • COLON comp_expr COLON comp_expr RBRACKET COLON comp_stmts KEYWORD_ENDFOR SEMICOLON
   88 comp_expr: comp_expr • PLUS comp_expr
   89          | comp_expr • MINUS comp_expr
   90          | comp_expr • MULT comp_expr
   91          | comp_expr • DIV comp_expr
   92          | comp_expr • MOD comp_expr
   93          | comp_expr • GT comp_expr
   94          | comp_expr • LT comp_expr
   95          | comp_expr • GEQ comp_expr
   96          | comp_expr • LEQ comp_expr
   97          | comp_expr • EQ comp_expr
   98          | comp_expr • NEQ comp_expr
   99          | comp_expr • KEYWORD_AND comp_expr
  100          | comp_expr • KEYWORD_OR comp_expr
  104          | comp_expr • POW comp_expr

    KEYWORD_OR   shift, and go to state 265
    KEYWORD_AND  shift, and go to state 266
    EQ           shift, and go to state 267
    NEQ          shift, and go to state 268
    LT           shift, and go to state 269
    LEQ          shift, and go to state 270
    GT           shift, and go to state 271
    GEQ          shift, and go to state 272
    PLUS         shift, and go to state 273
    MINUS        shift, and go to state 274
    MULT         shift, and go to state 275
    DIV          shift, and go to state 276
    MOD          shift, and go to state 277
    POW          shift, and go to state 278
    COLON        shift, and go to state 347


State 335

   70 comp_for_stmt: KEYWORD_FOR comp_var_name KEYWORD_IN LBRACKET expr • COLON expr RBRACKET COLON stmts KEYWORD_ENDFOR SEMICOLON
  108 expr: expr • PLUS expr
  109     | expr • MINUS expr
  110     | expr • MULT expr
  111     | expr • DIV expr
  112     | expr • MOD expr
  113     | expr • GT expr
  114     | expr • LT expr
  115     | expr • GEQ expr
  116     | expr • LEQ expr
  117     | expr • EQ expr
  118     | expr • NEQ expr
  119     | expr • KEYWORD_AND expr
  120     | expr • KEYWORD_OR expr
  124     | expr • POW expr

    KEYWORD_OR   shift, and go to state 77
    KEYWORD_AND  shift, and go to state 78
    EQ           shift, and go to state 79
    NEQ          shift, and go to state 80
    LT           shift, and go to state 81
    LEQ          shift, and go to state 82
    GT           shift, and go to state 83
    GEQ          shift, and go to state 84
    PLUS         shift, and go to state 85
    MINUS        shift, and go to state 86
    MULT         shift, and go to state 87
    DIV          shift, and go to state 88
    MOD          shift, and go to state 89
    POW          shift, and go to state 90
    COLON        shift, and go to state 348


State 336

   87 comp_expr: operand •  [KEYWORD_OR, KEYWORD_AND, EQ, NEQ, LT, LEQ, GT, GEQ, PLUS, MINUS, MULT, DIV, MOD, POW, RPAREN, COLON]
  107 expr: operand •  [KEYWORD_OR, KEYWORD_AND, EQ, NEQ, LT, LEQ, GT, GEQ, PLUS, MINUS, MULT, DIV, MOD, POW, RPAREN, COLON]

    KEYWORD_OR   reduce using rule 87 (comp_expr)
    KEYWORD_OR   [reduce using rule 107 (expr)]
    KEYWORD_AND  reduce using rule 87 (comp_expr)
    KEYWORD_AND  [reduce using rule 107 (expr)]
    EQ           reduce using rule 87 (comp_expr)
    EQ           [reduce using rule 107 (expr)]
    NEQ          reduce using rule 87 (comp_expr)
    NEQ          [reduce using rule 107 (expr)]
    LT           reduce using rule 87 (comp_expr)
    LT           [reduce using rule 107 (expr)]
    LEQ          reduce using rule 87 (comp_expr)
    LEQ          [reduce using rule 107 (expr)]
    GT           reduce using rule 87